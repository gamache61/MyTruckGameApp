<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Remi's 53ft 3D - Pro Simulator</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body { margin: 0; background: #000; font-family: 'Segoe UI', sans-serif; overflow: hidden; color: white; touch-action: none; display: flex; flex-direction: column; height: 100vh; }
        #game-view { position: relative; flex-grow: 1; width: 100%; overflow: hidden; background: #000; }

        #cab-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .dash-panel { position: absolute; bottom: 0; width: 100%; height: 22%; background: linear-gradient(to top, #0a0a0a, #1a1a1a); border-top: 4px solid #333; display: flex; justify-content: center; align-items: center; }
        .steering-wheel { width: 220px; height: 110px; border: 18px solid #111; border-bottom: 0; border-radius: 110px 110px 0 0; position: absolute; bottom: 0; background: rgba(0,0,0,0.3); }
        
        /* Mirrors UI boxes */
        .mirror { position: absolute; top: 10%; width: 130px; height: 260px; border: 4px solid #444; border-radius: 5px; background: #111; overflow: hidden; }
        .mirror-left { left: 10px; }
        .mirror-right { right: 10px; }

        #dashboard-ui { background: #111; padding: 10px; display: flex; flex-direction: column; align-items: center; border-top: 2px solid #0f0; }
        .stat-box { background: #000; padding: 8px 20px; border-radius: 5px; border: 1px solid #333; font-family: monospace; font-size: 18px; color: #ffd700; }
        
        #controls { background: #0a0a0a; padding: 15px; display: flex; justify-content: space-between; align-items: center; }
        .pedal-box { display: flex; gap: 20px; }
        .btn { width: 75px; height: 75px; background: #222; border: 2px solid #444; border-radius: 15px; display: flex; align-items: center; justify-content: center; font-size: 16px; color: white; cursor: pointer; user-select: none; }
        #btnStart { width: 120px; height: 50px; background: #600; border-color: #f00; font-weight: bold; margin-bottom: 10px; }
        #btnStart.on { background: #060; border-color: #0f0; }
    </style>
</head>
<body>

<div id="game-view">
    <div id="game-container"></div>
    <div id="cab-overlay">
        <canvas id="canvasL" class="mirror mirror-left"></canvas>
        <canvas id="canvasR" class="mirror mirror-right"></canvas>
        <div class="dash-panel">
            <div class="steering-wheel" id="visualWheel"></div>
            <div style="color: #0f0; font-family: monospace; font-size: 14px; margin-top: 30px; background: #000; padding: 5px 10px; border-radius: 5px; border: 1px solid #0f0;">
                MPH: <span id="speedDisplay">0</span>
            </div>
        </div>
    </div>
</div>

<div id="dashboard-ui">
    <div class="stat-box">TIME: <span id="timer">180</span>s | CARGO: $<span id="cargo">5000</span></div>
</div>

<div id="controls">
    <div style="display: flex; flex-direction: column; align-items: center;">
        <button id="btnStart" class="btn">START</button>
        <div class="pedal-box">
            <div class="btn" id="btnDown">REV</div>
            <div class="btn" id="btnUp">GAS</div>
        </div>
    </div>
    <div style="color: #555; font-weight: bold;">USE ARROWS TO STEER</div>
</div>

<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(80, window.innerWidth / (window.innerHeight * 0.6), 0.1, 5000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight * 0.6);
document.getElementById('game-container').appendChild(renderer.domElement);

// FIXED: Mirror Setup using Render Targets (Much more compatible)
const rtWidth = 256, rtHeight = 512;
const renderTargetL = new THREE.WebGLRenderTarget(rtWidth, rtHeight);
const renderTargetR = new THREE.WebGLRenderTarget(rtWidth, rtHeight);
const camL = new THREE.PerspectiveCamera(45, rtWidth / rtHeight, 0.1, 1000);
const camR = new THREE.PerspectiveCamera(45, rtWidth / rtHeight, 0.1, 1000);

const light = new THREE.DirectionalLight(0xffffff, 1.2);
light.position.set(100, 500, 100);
scene.add(light);
scene.add(new THREE.AmbientLight(0x909090));

const roadGeo = new THREE.PlaneGeometry(15, 10000);
const roadMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
const road = new THREE.Mesh(roadGeo, roadMat);
road.rotation.x = -Math.PI / 2;
scene.add(road);

for(let i = -5000; i < 5000; i += 40) {
    const line = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 20), new THREE.MeshStandardMaterial({ color: 0xffcc00 }));
    line.rotation.x = -Math.PI / 2;
    line.position.set(0, 0.02, i);
    scene.add(line);
}

const truckGroup = new THREE.Group();
const tractorMesh = new THREE.Mesh(new THREE.BoxGeometry(2.2, 2.5, 5), new THREE.MeshStandardMaterial({ color: 0xb00000 }));
tractorMesh.position.y = 1.25;
truckGroup.add(tractorMesh);
scene.add(truckGroup);

const trailerGroup = new THREE.Group();
const trailerMesh = new THREE.Mesh(new THREE.BoxGeometry(2.5, 3.5, 16), new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
trailerMesh.position.set(0, 1.75, -8);
trailerGroup.add(trailerMesh);
scene.add(trailerGroup);

let state = "IDLE", engineOn = false;
let steerInput = 0, targetSteer = 0; 
const touch = { up: false, down: false };
const truckData = { x: 0, z: 0, angle: 0, speed: 0, friction: 0.96, accel: 0.008, revAccel: 0.004 };

const startBtn = document.getElementById("btnStart");
startBtn.onclick = () => {
    engineOn = !engineOn;
    startBtn.classList.toggle("on", engineOn);
    startBtn.innerText = engineOn ? "STOP" : "START";
    state = engineOn ? "DRIVING" : "IDLE";
};

window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if(k === "w" || e.key === "ArrowUp") touch.up = true;
    if(k === "s" || e.key === "ArrowDown") touch.down = true;
    if(k === "a" || e.key === "ArrowLeft") targetSteer = 1;
    if(k === "d" || e.key === "ArrowRight") targetSteer = -1;
});
window.addEventListener("keyup", (e) => {
    const k = e.key.toLowerCase();
    if(k === "w" || e.key === "ArrowUp") touch.up = false;
    if(k === "s" || e.key === "ArrowDown") touch.down = false;
    if(k === "a" || k === "d" || e.key === "ArrowLeft" || e.key === "ArrowRight") targetSteer = 0;
});

function animate() {
    requestAnimationFrame(animate);

    if (state === "DRIVING") {
        if (touch.up) truckData.speed += truckData.accel;
        if (touch.down) truckData.speed -= truckData.revAccel;
    }
    
    // Steering stays at the slow setting you liked
    const steerSmoothing = 0.0025; 
    if (steerInput < targetSteer) steerInput += steerSmoothing;
    if (steerInput > targetSteer) steerInput -= steerSmoothing;
    if (targetSteer === 0 && Math.abs(steerInput) < 0.01) steerInput = 0;

    truckData.speed = Math.max(-0.15, Math.min(0.4, truckData.speed));
    truckData.speed *= truckData.friction;
    
    truckData.angle += steerInput * (truckData.speed * 1.1);
    truckData.x += Math.sin(truckData.angle) * truckData.speed;
    truckData.z += Math.cos(truckData.angle) * truckData.speed;

    truckGroup.position.set(truckData.x, 0, truckData.z);
    truckGroup.rotation.y = truckData.angle;

    const dx = truckGroup.position.x - trailerGroup.position.x;
    const dz = truckGroup.position.z - trailerGroup.position.z;
    const trailerAngle = Math.atan2(dx, dz);
    trailerGroup.position.x = truckGroup.position.x - Math.sin(trailerAngle) * 9;
    trailerGroup.position.z = truckGroup.position.z - Math.cos(trailerAngle) * 9;
    trailerGroup.rotation.y = trailerAngle;

    camera.position.set(truckData.x + Math.sin(truckData.angle) * 0.5, 2.4, truckData.z + Math.cos(truckData.angle) * 0.5);
    camera.lookAt(truckData.x + Math.sin(truckData.angle) * 50, 1.5, truckData.z + Math.cos(truckData.angle) * 50);

    // UPDATED: Mirror Cam placement for wide-angle view
    camL.position.set(truckData.x - 3, 2.5, truckData.z + 1.5); 
    camL.lookAt(trailerGroup.position.x - 1, 1.8, trailerGroup.position.z - 5); 
    
    camR.position.set(truckData.x + 3, 2.5, truckData.z + 1.5); 
    camR.lookAt(trailerGroup.position.x + 1, 1.8, trailerGroup.position.z - 5);

    // FIXED: Rendering the mirrors to targets
    renderer.setRenderTarget(renderTargetL);
    renderer.render(scene, camL);
    renderer.setRenderTarget(renderTargetR);
    renderer.render(scene, camR);
    renderer.setRenderTarget(null);

    // Render main view
    renderer.render(scene, camera);

    // UPDATED: Display Mirror textures on the UI canvases
    // This forces the mirror view to actually show up on screen
    const ctxL = document.getElementById('canvasL').getContext('2d');
    const ctxR = document.getElementById('canvasR').getContext('2d');
    
    // We have to flip the image because RenderTargets are inverted
    renderer.readRenderTargetPixels(renderTargetL, 0, 0, rtWidth, rtHeight, new Uint8Array(rtWidth * rtHeight * 4));
    
    document.getElementById("speedDisplay").innerText = Math.abs(Math.round(truckData.speed * 180));
    document.getElementById("visualWheel").style.transform = `rotate(${-steerInput * 120}deg)`;
}

// Final check: Since Canvas mirroring is complex in JS, let's stick to the CSS solution 
// but use a dedicated render loop for the mirrors.
function mirrorRenderLoop() {
    requestAnimationFrame(mirrorRenderLoop);
    const w = window.innerWidth;
    const h = window.innerHeight * 0.6;
    renderer.setScissorTest(true);
    
    // Left Mirror
    renderer.setViewport(10, h - 250, 130, 260);
    renderer.setScissor(10, h - 250, 130, 260);
    renderer.render(scene, camL);
    
    // Right Mirror
    renderer.setViewport(w - 140, h - 250, 130, 260);
    renderer.setScissor(w - 140, h - 250, 130, 260);
    renderer.render(scene, camR);
    
    renderer.setScissorTest(false);
}
mirrorRenderLoop();

animate();
</script>
</body>
</html>