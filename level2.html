<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Remi's Semi - Level 2 (Layout Adjusted)</title>
    <style>
        body { margin: 0; background: #2d613e; font-family: 'Segoe UI', sans-serif; overflow: hidden; color: white; touch-action: none; height: 100vh; width: 100vw; -webkit-user-select: none; user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; }
        #model-name { position: absolute; top: 5px; right: 10px; color: rgba(255,255,255,0.3); font-size: 10px; z-index: 20; }
        #dashboard { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 10; pointer-events: none; text-align: center; width: 100%; }
        #msg { font-size: 16px; color: #ffd700; text-shadow: 2px 2px #000; font-weight: bold; margin-bottom: 5px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 15px; display: inline-block; width: 94%; line-height: 1.2; box-sizing: border-box; border: 1px solid #444; transition: background 0.2s; }
        #gps-screen { position: absolute; bottom: 454px; left: 50%; transform: translateX(-50%); width: 90px; height: 30px; background: rgba(0, 0, 0, 0.8); border: 2px solid #ffd700; border-radius: 5px; color: #ffd700; font-family: 'Courier New', monospace; font-weight: bold; font-size: 14px; z-index: 20; pointer-events: none; display: flex; align-items: center; justify-content: center; text-align: center; box-shadow: 0 0 10px rgba(0,0,0,0.5); line-height: 1.1; padding: 2px; box-sizing: border-box; }
        #msg.warning { background: rgba(200, 0, 0, 0.9); color: white; border: 2px solid #ff0000; }
        #msg.repair { background: rgba(255, 140, 0, 0.9); color: white; border: 2px solid #ffae00; }
        #bottom-stats { display: flex; justify-content: space-between; align-items: center; padding: 0 3%; margin-top: 5px; pointer-events: auto; }
        .stat-box { background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 5px; border: 1px solid #444; font-family: monospace; font-size: 16px; pointer-events: none; }
        #btnBackToStart { width: 35px; height: 35px; border-radius: 50%; background: #ffd700; color: #000; font-weight: bold; font-size: 20px; border: 2px solid #000; display: flex; align-items: center; justify-content: center; pointer-events: auto; cursor: pointer; text-decoration: none; position: absolute; top: 0; left: 10px; }
        #controls { position: absolute; bottom: 15px; width: 100%; display: flex; justify-content: space-between; align-items: flex-end; padding: 0 10px; box-sizing: border-box; z-index: 10; pointer-events: none; }
        .left-controls { display: flex; flex-direction: column; gap: 6px; align-items: flex-start; pointer-events: auto; }
        .pedal-box { display: flex; gap: 5px; }
        #steering-pad { width: 160px; height: 60px; background: transparent; border-radius: 30px; position: absolute; right: -20px; bottom: 96px; touch-action: none; pointer-events: auto; display: flex; align-items: center; justify-content: center; }
        #steering-wheel { width: 30px; height: 30px; background: #000; border: none; border-radius: 50%; box-sizing: border-box; position: relative; transition: transform 0.1s linear; box-shadow: 0 4px 10px rgba(0,0,0,0.5); pointer-events: none; }
        .btn { width: 55px; height: 48px; background: rgba(51,51,51,0.8); border: 2px solid #555; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 10px; color: white; user-select: none; pointer-events: auto; }
        #btnStart { background: rgba(80,0,0,0.8); border-color: #f00; height: 32px; font-weight: bold; }
        #btnStart.on { background: rgba(0,80,0,0.8); border-color: #0f0; }
        #btnView { height: 32px; font-size: 8px; background: rgba(0, 100, 200, 0.8); }
        #btnSkip { height: 32px; font-size: 8px; background: rgba(128, 0, 128, 0.8); border-color: #a020f0; }
        #btnSave { height: 32px; font-size: 8px; background: rgba(0, 150, 0, 0.8); border-color: #0f0; }
        #victory-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        #victory-overlay h1 { color: #ffd700; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px #ffd700; text-align: center; }
        .continue-btn { padding: 15px 30px; font-size: 18px; background: #ffd700; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; color: black; }
    </style>
</head>
<body oncontextmenu="return false;">

<div id="model-name">Model: Gemini 3 Flash</div>

<div id="dashboard">
    <div id="msg">MISSION: DRIVE BACK TO THE YARD AND GET LOADED FOR THE NEXT CUSTOMER</div>
    <div id="bottom-stats">
        <div class="stat-box" style="color: #33ccff;">TIME: <span id="timer">00:00</span></div>
        <div class="stat-box" style="color: #ff3333;">DMG: <span id="damage">0%</span></div>
        <div class="stat-box" style="color: #ff9900;">DIST: <span id="miles">0.0</span></div>
        <a href="index.html" id="btnBackToStart">?</a>
    </div>
</div>

<div id="gps-screen">STRAIGHT</div>

<div id="victory-overlay">
    <h1 id="victory-msg">LOADED & READY!<br>LEVEL 2 COMPLETE</h1>
    <button class="continue-btn" onclick="startLevel3()">Head to Next Customer</button>
</div>

<canvas id="gameCanvas"></canvas>

<div id="controls">
    <div class="left-controls">
        <div class="pedal-box">
            <div id="btnDown" class="btn">REV</div>
            <div id="btnUp" class="btn">GAS</div>
        </div>
        <div style="display: flex; gap: 4px; margin-top: 4px;">
            <button id="btnStart" class="btn">START</button>
            <button id="btnView" class="btn">VIEW</button>
            <button id="btnSave" class="btn" onclick="toggleEditMode()">EDIT</button>
            <button id="btnDrop" class="btn" style="height:32px; font-size: 8px; background: rgba(200, 100, 0, 0.8);" onclick="handleHitch()">DROP/HOOK</button>
            <button id="btnSkip" class="btn" onclick="skipToGravel()">SKIP</button>
        </div>
    </div>
    <div id="steering-pad"><div id="steering-wheel"></div></div>
</div>

<script>
const roadBaseY = 850;
const siteLocationX = 4000; 
const roadWidth = 254; 
const lumberRoadLength = 1200;

const remoteLumberYard = { x: siteLocationX - 1625, y: roadBaseY + roadWidth + lumberRoadLength, w: 3250, h: 3600 };

const loadingZone = { 
    x: remoteLumberYard.x + (remoteLumberYard.w/2) - (roadWidth/2), 
    y: remoteLumberYard.y + 550, 
    w: roadWidth, 
    h: 800 
};

const gravelRoadX = siteLocationX - 8000; 
const gravelRoadLength = 2000;

let turnRadius = parseFloat(localStorage.getItem('remiSemi_turnRadius')) || 450; 
let isEditMode = false; 

const endYard = { x: gravelRoadX - 1200, y: -2800, w: 2400, h: 1800 };
let junctionHandleLeft = { x: gravelRoadX - roadWidth/2 - turnRadius, y: 0 };
let junctionHandleRight = { x: gravelRoadX + roadWidth/2 + turnRadius, y: 0 };
let activeEditTarget = null;
const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

function skipToGravel() {
    tractor.x = siteLocationX;
    tractor.y = roadBaseY + roadWidth + 50;
    tractor.angle = Math.PI / 2;
    tractor.speed = 0;
    truckDamage = 0;
    recoveryTimer = 0;
    if (activeTrailer) {
        activeTrailer.angle = tractor.angle;
        activeTrailer.x = tractor.x - Math.cos(tractor.angle) * 440;
        activeTrailer.y = tractor.y - Math.sin(tractor.angle) * 440;
    }
}

function toggleEditMode() {
    const btn = document.getElementById("btnSave");
    const msgBox = document.getElementById("msg");
    if (!isEditMode) {
        isEditMode = true;
        btn.innerText = "SAVE";
        btn.style.background = "rgba(200, 0, 0, 0.8)";
        msgBox.innerText = "EDIT MODE: DRAG HANDLES ON ANY ITEM TO MOVE";
    } else {
        isEditMode = false;
        btn.innerText = "EDIT";
        btn.style.background = "rgba(0, 150, 0, 0.8)";
        localStorage.setItem('remiSemi_turnRadius', turnRadius);
        localStorage.setItem('remiSemi_trees', JSON.stringify(trees));
        msgBox.innerText = "LAYOUT SAVED!";
        setTimeout(() => { msgBox.innerText = "MISSION: DRIVE BACK TO THE YARD..."; }, 2000);
    }
}

let dustParticles = [];
function createDust(x, y) {
    if (Math.abs(tractor.speed) < 1) return;
    dustParticles.push({ x, y, size: 5 + Math.random() * 15, alpha: 0.6, life: 1.0 });
}

function getRoadY(x) {
    if (x > siteLocationX - 1200) return roadBaseY;
    const targetY = roadBaseY + Math.sin(x / 1400) * 850;
    if (x > siteLocationX - 2500) {
        let weight = (x - (siteLocationX - 2500)) / 1300;
        return (targetY * (1 - weight)) + (roadBaseY * weight);
    }
    return targetY;
}

let timeElapsed = 0, totalDistance = 0, gameActive = true, timerStarted = false;
let liftsLoaded = 0;
let truckDamage = 0;
let accidents = 0;
let isRepairing = false;
let repairTimer = 0;
let offRoadTimer = 0;
let recoveryTimer = 0;
let gracePeriod = 0;

let serviceTruck = { x: 0, y: 0, angle: 0, active: false, flashState: false };

let lumberStacks = [];
for(let side = 0; side < 2; side++) {
    let baseSideX = side === 0 ? -750 : 450; 
    for(let block = 0; block < 3; block++) {
        let blockYOffset = block * 450;
        for(let row = 0; row < 3; row++) {
            for(let col = 0; col < 4; col++) {
                lumberStacks.push({ 
                    x: loadingZone.x + baseSideX + (col * 140), 
                    y: (loadingZone.y + 100 + blockYOffset + (row * 80)) - 200, 
                    w: 120, 
                    h: 60,
                    exists: true 
                });
            }
        }
    }
}

// FIX: Repositioned to the center of the lane between stacks and loading zone
let forklift = { 
    x: loadingZone.x - 350, 
    y: loadingZone.y + 250, 
    angle: Math.PI, 
    state: "idle", 
    carrying: false, 
    path: [],
    pathIndex: 0,
    speed: 7
};

const savedTrees = localStorage.getItem('remiSemi_trees');
let trees = savedTrees ? JSON.parse(savedTrees) : [];
if (trees.length === 0) {
    for(let i=0; i<100; i++) {
        let tx = (Math.random() - 0.5) * 15000 + 2000;
        let ty = (Math.random() - 0.5) * 10000 + 1000;
        let distToYard = Math.sqrt(Math.pow(tx - loadingZone.x, 2) + Math.pow(ty - loadingZone.y, 2));
        if (distToYard > 1000) {
            trees.push({ x: tx, y: ty, size: 40 + Math.random() * 30, rotation: Math.random() * Math.PI * 2 });
        }
    }
}

const canvas = document.getElementById("gameCanvas"), ctx = canvas.getContext("2d");
const padEl = document.getElementById("steering-pad"), wheelEl = document.getElementById("steering-wheel"), startBtn = document.getElementById("btnStart");

let engineOn = false;
const touch = { up: false, down: false }; let currentZoom = 0.35; 

const initialExitX = gravelRoadX;
const initialExitY = getRoadY(initialExitX) - roadWidth + 300;
const tractor = { x: initialExitX, y: initialExitY, w: 292.5, h: 67.5, angle: Math.PI / 2, speed: 0, accel: 0.05, revAccel: 0.04, friction: 0.98, steerAngle: 0 };
const camera = { x: 0, y: 0 };

let allTrailers = [{ x: tractor.x, y: tractor.y - 440, w: 550, h: 92, angle: Math.PI / 2, type: 'flatbed' }];
let activeTrailer = allTrailers[0];
let isSteeringActive = false; 

const timerInterval = setInterval(() => { 
    if (!gameActive || !timerStarted) return; 
    timeElapsed++; 
    if (isRepairing) {
        repairTimer--;
        serviceTruck.flashState = !serviceTruck.flashState;
        if (repairTimer <= 0) {
            isRepairing = false;
            serviceTruck.active = false;
            truckDamage = Math.max(0, truckDamage - 30);
            document.getElementById("msg").classList.remove("repair");
            gracePeriod = 10; 
            startBtn.innerText = "START";
        }
    }
    if (recoveryTimer > 0) { recoveryTimer--; if (recoveryTimer <= 0) gracePeriod = 10; }
    if (gracePeriod > 0) gracePeriod--;
    const mins = Math.floor(timeElapsed / 60); 
    const secs = timeElapsed % 60; 
    document.getElementById("timer").innerText = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`; 
}, 1000);

function handleHitch() {
    if (activeTrailer) activeTrailer = null;
    else allTrailers.forEach(t => { if (Math.sqrt(Math.pow(tractor.x - t.x, 2) + Math.pow(tractor.y - t.y, 2)) < 300) activeTrailer = t; });
}

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();

function drawTree(t) { 
    ctx.save();
    ctx.translate(t.x, t.y); ctx.rotate(t.rotation); ctx.fillStyle = "#1b4d2c"; ctx.beginPath(); ctx.arc(0, 0, t.size, 0, Math.PI*2); ctx.fill();
    if (isEditMode) { ctx.fillStyle = "rgba(255, 215, 0, 0.7)"; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill(); }
    ctx.restore(); 
}

function drawLumberLift(x, y, w, h) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = "#e3c5a8";
    ctx.fillRect(0, 0, w, h);
    ctx.strokeStyle = "#8b4513";
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, w, h);
    ctx.save(); ctx.clip();
    for(let i = 0; i < h; i += 4) {
        ctx.fillStyle = "rgba(0,0,0,0.05)";
        ctx.fillRect(0, i + 3, w, 1);
    }
    ctx.restore();
    ctx.fillStyle = "#111";
    ctx.fillRect(w * 0.2, 0, 3, h);
    ctx.fillRect(w * 0.8, 0, 3, h);
    ctx.restore();
}

function drawForklift(x, y, angle) { 
    ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
    ctx.fillStyle = "#e67e22"; ctx.fillRect(-40, -25, 80, 50); 
    ctx.fillStyle = "#333"; ctx.fillRect(40, -22, 10, 44); 
    ctx.fillStyle = "#333";
    ctx.fillRect(50, -20, 40, 5); 
    ctx.fillRect(50, 15, 40, 5);
    if (forklift.carrying) { ctx.fillStyle = "#d2b48c"; ctx.fillRect(55, -30, 60, 60); }
    ctx.fillStyle = "#111"; 
    ctx.fillRect(-35, -28, 20, 8); ctx.fillRect(-35, 20, 20, 8);
    ctx.fillRect(25, -28, 15, 8);
    ctx.fillRect(25, 20, 15, 8);
    ctx.restore(); 
}

function drawRealisticOffice(x, y, w, h) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(Math.PI);
    ctx.shadowBlur = 15;
    ctx.shadowColor = "rgba(0,0,0,0.5)";
    ctx.shadowOffsetY = 10;
    const roofGrd = ctx.createLinearGradient(-w/2, -h/2, w/2, -h/2);
    roofGrd.addColorStop(0, "#444");
    roofGrd.addColorStop(0.5, "#666");
    roofGrd.addColorStop(1, "#444");
    ctx.fillStyle = roofGrd;
    ctx.fillRect(-w/2, -h/2, w, h);
    ctx.shadowBlur = 0;
    ctx.shadowOffsetY = 0;
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 2;
    for(let i = -w/2; i < w/2; i += 15) {
        ctx.beginPath();
        ctx.moveTo(i, -h/2);
        ctx.lineTo(i, h/2);
        ctx.stroke();
    }
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.fillRect(-w/2 + 50, -h/2 + 50, w - 100, h - 100);
    ctx.fillStyle = "#ffcc00";
    ctx.font = "bold 40px Arial";
    ctx.textAlign = "center";
    ctx.fillText("YARD OFFICE", 0, 15);
    ctx.restore();
}

function drawLumberYardGround() {
    ctx.save();
    ctx.translate(remoteLumberYard.x, remoteLumberYard.y);
    ctx.fillStyle = "#555";
    ctx.fillRect(0, 0, remoteLumberYard.w, remoteLumberYard.h);
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 10;
    ctx.strokeRect(0, 0, remoteLumberYard.w, remoteLumberYard.h);
    ctx.strokeStyle = "#ffd700";
    ctx.lineWidth = 8;
    ctx.setLineDash([20, 15]);
    ctx.strokeRect(loadingZone.x - remoteLumberYard.x - 10, loadingZone.y - remoteLumberYard.y - 10, loadingZone.w + 20, loadingZone.h + 20);
    ctx.setLineDash([]);
    ctx.save();
    ctx.translate(loadingZone.x - remoteLumberYard.x + loadingZone.w/2, loadingZone.y - remoteLumberYard.y + loadingZone.h/2);
    ctx.rotate(Math.PI);
    ctx.fillStyle = "rgba(255, 215, 0, 0.4)";
    ctx.font = "bold 60px Arial";
    ctx.textAlign = "center";
    ctx.fillText("LOADING", 0, -15);
    ctx.fillText("ZONE", 0, 55);
    ctx.restore();
    ctx.restore();
}

function drawConstructionSiteDetails() {
    ctx.save();
    ctx.translate(endYard.x, endYard.y);
    ctx.fillStyle = "#777"; ctx.fillRect(0, 0, endYard.w, endYard.h);
    const uzW = (roadWidth + 50) * 1.2;
    const uzH = 600 * 1.2;
    const uzX = 50;
    const uzY = 50;
    ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
    ctx.fillRect(uzX, uzY, uzW, uzH);
    ctx.strokeStyle = "#ffd700"; ctx.lineWidth = 10;
    ctx.setLineDash([20,20]);
    ctx.strokeRect(uzX, uzY, uzW, uzH);
    ctx.setLineDash([]);
    ctx.restore();
}

function drawConstructionSign(x, y) {
    ctx.save(); ctx.translate(x, y);
    ctx.fillStyle = "#444";
    ctx.fillRect(-5, 0, 10, 80);
    ctx.fillStyle = "#ff8800"; ctx.strokeStyle = "white"; ctx.lineWidth = 4;
    ctx.fillRect(-100, -60, 200, 80);
    ctx.strokeRect(-100, -60, 200, 80);
    ctx.fillStyle = "black"; ctx.font = "bold 18px Arial"; ctx.textAlign = "center";
    ctx.fillText("CONSTRUCTION", 0, -30);
    ctx.fillText("SITE", 0, -5);
    ctx.restore();
}

function drawTrailerStatic(x, y, angle, type) {
    const th = 92;
    const tw = 550; 
    ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
    ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(-tw/2 + 5, -th/2 + 5, tw, th);
    for(let i = -th/2; i < th/2; i += 8) { ctx.fillStyle = (Math.floor(i/8) % 2 === 0) ? "#5d4037" : "#4a352f"; ctx.fillRect(-tw/2, i, tw, 8); }
    ctx.fillStyle = "#b0b0b0"; ctx.fillRect(-tw/2, -th/2, tw, 6);
    ctx.fillRect(-tw/2, th/2 - 6, tw, 6); 
    for(let i = -tw/2; i < tw/2; i += 20) { ctx.fillStyle = (Math.floor(i/20) % 2 === 0) ? "#d32f2f" : "#ffffff"; ctx.fillRect(i, -th/2 + 1, 10, 2); ctx.fillRect(i, th/2 - 3, 10, 2); }
    ctx.fillStyle = "#1a1a1a"; for(let i = -tw/2 + 15; i < tw/2; i += 40) { ctx.fillStyle = (Math.floor(i/40) % 2 === 0) ? "#d32f2f" : "#ffffff"; ctx.fillRect(i, -th/2, 8, 3); ctx.fillRect(i, th/2 - 3, 8, 3); }
    ctx.fillStyle = "#d2b48c";
    for(let i=0; i<liftsLoaded; i++) { 
        let col = i % 6;
        let row = (i < 6) ? 0 : 1;
        ctx.fillRect(-tw/2 + 20 + col*80, -th/2 + 10 + (row * 35), 70, 30);
    }
    ctx.strokeStyle = "#ffd700"; ctx.lineWidth = 3;
    for(let i = -tw/2 + 55; i < tw/2 - 50; i += 80) { ctx.beginPath(); ctx.moveTo(i, th/2 - 6); ctx.lineTo(i, -th/2 + 6); ctx.stroke(); }
    ctx.fillStyle = "#000"; ctx.fillRect(-tw/2 + 40, -th/2 - 5, 60, 10);
    ctx.fillRect(-tw/2 + 40, th/2 - 5, 60, 10); ctx.fillStyle = "#333";
    ctx.fillRect(-tw/2, -th/2, 5, th); ctx.restore();
}

function drawTruckDetailed(x, y, angle, isSteering = false, cabColor = "#800000") {
    ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
    if (gracePeriod > 0) ctx.globalAlpha = 0.6;
    const s = 2.25; 
    ctx.fillStyle = "#111"; 
    ctx.fillRect((-130*s)/2, (-30*s)/6, (130*s) - (50*s), (30*s)/3);
    ctx.fillRect(0, (-30*s)/2, 60*s, 30*s); 
    ctx.fillStyle = "#000"; 
    ctx.fillRect(-62*s, -12*s, 12*s, 6*s); ctx.fillRect(-62*s, 6*s, 12*s, 6*s); 
    ctx.fillRect(-45*s, -12*s, 12*s, 6*s); ctx.fillRect(-45*s, 6*s, 12*s, 6*s); 
    ctx.save(); ctx.translate(46*s, (-30*s)/2 + 0.5); if(isSteering) ctx.rotate(tractor.steerAngle); ctx.fillRect(-6*s, -2.5*s, 12*s, 5*s); ctx.restore();
    ctx.save(); ctx.translate(46*s, (30*s)/2 - 0.5); if(isSteering) ctx.rotate(tractor.steerAngle); ctx.fillRect(-6*s, -2.5*s, 12*s, 5*s); ctx.restore();
    ctx.fillStyle = cabColor; 
    ctx.fillRect(-10*s, (-30*s)/2, 40*s, 30*s);
    ctx.fillRect(30*s, (-30*s)/2 + 4*s, 30*s, (30*s) - 8*s); 
    ctx.fillStyle = "#777";
    ctx.fillRect(-12*s, (-30*s)/2 - 5*s, 6*s, 6*s); 
    ctx.fillRect(-12*s, (30*s)/2 - 1*s, 6*s, 6*s);  
    ctx.fillStyle = "#FFD700"; 
    for(let i = 0; i < 4; i++) { 
        let ly = (-30*s)/2 + 4*s + (i * 6.5 * s); 
        ctx.fillRect(27*s, ly, 3*s, 3*s); 
    }
    ctx.fillStyle = "#aaa"; 
    ctx.fillRect(30*s, (-30*s)/2 - 4*s, 4*s, 5*s); 
    ctx.fillRect(30*s, (30*s)/2 - 1*s, 4*s, 5*s);  
    const bumperGrd = ctx.createLinearGradient(58 * s, 0, 65 * s, 0);
    bumperGrd.addColorStop(0, "#888"); bumperGrd.addColorStop(0.5, "#eee"); bumperGrd.addColorStop(1, "#999");
    ctx.fillStyle = bumperGrd;
    ctx.fillRect(58 * s, (-30 * s) / 2 - 1, 5 * s, 30 * s + 2);
    ctx.restore();
}

function planProfessionalLoad() {
    if (!activeTrailer || liftsLoaded >= 12) return;
    let col = liftsLoaded % 6;
    let stack = lumberStacks.find(s => s.exists);
    if (!stack) return;
    const stopOffset = -85; 
    let cos = Math.cos(activeTrailer.angle);
    let sin = Math.sin(activeTrailer.angle);
    let dropOffsetX = -activeTrailer.w/2 + 60 + (col * 85);
    let dropOffsetY = stopOffset; 
    let dropX = activeTrailer.x + (dropOffsetX * cos - dropOffsetY * sin);
    let dropY = activeTrailer.y + (dropOffsetX * sin + dropOffsetY * cos);
    let approachOffsetY = stopOffset - 300;
    let approachX = activeTrailer.x + (dropOffsetX * cos - approachOffsetY * sin);
    let approachY = activeTrailer.y + (dropOffsetX * sin + approachOffsetY * cos);
    let rearWayoffsetX = -activeTrailer.w/2 - 200;
    let rearWayoffsetY = stopOffset - 300;
    let rearWayX = activeTrailer.x + (rearWayoffsetX * cos - rearWayoffsetY * sin);
    let rearWayY = activeTrailer.y + (rearWayoffsetX * sin + rearWayoffsetY * cos);
    forklift.path = [];
    forklift.pathIndex = 0;
    forklift.path.push({x: stack.x + 150, y: stack.y, ang: 0, act: 'move'});
    forklift.path.push({x: stack.x, y: stack.y, ang: 0, act: 'grab'});
    forklift.path.push({x: stack.x + 150, y: stack.y, ang: 0, act: 'move'});
    forklift.path.push({x: rearWayX, y: rearWayY, ang: activeTrailer.angle, act: 'move'});
    forklift.path.push({x: approachX, y: approachY, ang: activeTrailer.angle + Math.PI/2, act: 'move'});
    forklift.path.push({x: dropX, y: dropY, ang: activeTrailer.angle + Math.PI/2, act: 'drop'});
    forklift.path.push({x: approachX, y: approachY, ang: activeTrailer.angle + Math.PI/2, act: 'move'});
    forklift.path.push({x: rearWayX, y: rearWayY, ang: activeTrailer.angle, act: 'move'});
    forklift.state = "moving";
}

function updateForklift() {
    if (forklift.state === "idle" && activeTrailer) {
        let checkX = activeTrailer.x, checkY = activeTrailer.y;
        if (checkX > loadingZone.x && checkX < loadingZone.x + loadingZone.w && checkY > loadingZone.y && checkY < loadingZone.y + loadingZone.h && Math.abs(tractor.speed) < 0.1) {
            planProfessionalLoad();
        }
    }
    if (forklift.path.length > 0 && forklift.pathIndex < forklift.path.length) {
        let target = forklift.path[forklift.pathIndex];
        let dx = target.x - forklift.x, dy = target.y - forklift.y, dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > 5) {
            forklift.x += (dx / dist) * forklift.speed;
            forklift.y += (dy / dist) * forklift.speed;
            let angleDiff = target.ang - forklift.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            forklift.angle += angleDiff * 0.1;
        } else {
            if (target.act === 'grab') {
                forklift.carrying = true;
                let stack = lumberStacks.find(s => s.exists);
                if (stack) stack.exists = false;
            } else if (target.act === 'drop') {
                forklift.carrying = false;
                liftsLoaded++;
                if(liftsLoaded >= 12) { gameActive = false; document.getElementById("victory-overlay").style.display = "flex"; }
            }
            forklift.pathIndex++;
            if (forklift.pathIndex >= forklift.path.length) forklift.state = "idle";
        }
    }
}

function update() {
    if (!gameActive) return;
    if (isRepairing) { 
        tractor.speed *= 0.8;
        let dx = (tractor.x - Math.cos(tractor.angle + 0.5) * 150) - serviceTruck.x;
        let dy = (tractor.y - Math.sin(tractor.angle + 0.5) * 150) - serviceTruck.y; 
        serviceTruck.x += dx * 0.05; serviceTruck.y += dy * 0.05; 
        return; 
    }
    if (recoveryTimer > 0) { tractor.speed *= 0.8; return; }
    if (truckDamage >= 100) { engineOn = false; startBtn.classList.remove("on"); startBtn.innerText = "TOTALED"; }
    if (engineOn) { 
        if (touch.up || keys.ArrowUp) tractor.speed += tractor.accel;
        if (touch.down || keys.ArrowDown) tractor.speed -= tractor.revAccel; 
    }
    tractor.speed *= tractor.friction;
    if (!isSteeringActive) { 
        if (keys.ArrowLeft) { tractor.steerAngle = -0.6; wheelEl.style.transform = `translateX(-50px)`; } 
        else if (keys.ArrowRight) { tractor.steerAngle = 0.6; wheelEl.style.transform = `translateX(50px)`; } 
        else { tractor.steerAngle += (0 - tractor.steerAngle) * 0.12; if (Math.abs(tractor.steerAngle) < 0.001) { tractor.steerAngle = 0; wheelEl.style.transform = `translateX(0px)`; } }
    }
    let distToLumberYard = Math.sqrt(Math.pow(tractor.x - loadingZone.x, 2) + Math.pow(tractor.y - loadingZone.y, 2)) / 1000;
    document.getElementById("miles").innerText = distToLumberYard.toFixed(1);
    tractor.angle += (tractor.speed / 120) * Math.tan(tractor.steerAngle * 1.0); 
    tractor.x += Math.cos(tractor.angle) * tractor.speed;
    tractor.y += Math.sin(tractor.angle) * tractor.speed;
    const gps = document.getElementById("gps-screen"); 
    let mainY = getRoadY(initialExitX);
    if (tractor.x < gravelRoadX + 300 && tractor.y < mainY) { gps.innerText = "LEFT"; } 
    else if (tractor.y < mainY && tractor.x > siteLocationX - 500) { gps.innerText = "RIGHT"; } 
    else { gps.innerText = "STRAIGHT"; }
    let offRoad = true; 
    let currentRoadY = getRoadY(tractor.x);
    if (tractor.y > currentRoadY && tractor.y < currentRoadY + roadWidth) offRoad = false;
    if (tractor.x > siteLocationX - roadWidth/2 && tractor.x < siteLocationX + roadWidth/2 && tractor.y > currentRoadY && tractor.y < currentRoadY + roadWidth + lumberRoadLength) offRoad = false;
    if (tractor.x > remoteLumberYard.x && tractor.x < remoteLumberYard.x + remoteLumberYard.w && tractor.y > remoteLumberYard.y && tractor.y < remoteLumberYard.y + remoteLumberYard.h) offRoad = false;
    if (tractor.x > endYard.x && tractor.x < endYard.x + endYard.w && tractor.y > endYard.y && tractor.y < endYard.y + endYard.h) offRoad = false;
    dustParticles.forEach((p, i) => { p.life -= 0.02; p.alpha -= 0.01; p.size += 0.5; if (p.life <= 0) dustParticles.splice(i, 1); });
    if (offRoad && Math.abs(tractor.speed) > 0.5) { truckDamage += 0.05; offRoadTimer++; if (gracePeriod <= 0) tractor.speed *= 0.95; } 
    if (gracePeriod <= 0) { 
        trees.forEach(t => { 
            let dx = tractor.x - t.x, dy = tractor.y - t.y, dist = Math.sqrt(dx*dx + dy*dy); 
            if (dist < t.size + 30) { truckDamage += 5; accidents++; tractor.speed = -tractor.speed * 0.5; recoveryTimer = 10; } 
        });
    }
    document.getElementById("damage").innerText = Math.floor(Math.min(100, truckDamage)) + "%";
    if (activeTrailer) { 
        const pX = tractor.x - Math.cos(tractor.angle) * 101.25, pY = tractor.y - Math.sin(tractor.angle) * 101.25, dx = pX - activeTrailer.x, dy = pY - activeTrailer.y;
        activeTrailer.angle = Math.atan2(dy, dx); 
        activeTrailer.x = pX - Math.cos(activeTrailer.angle) * (activeTrailer.w / 2 - 33.75);
        activeTrailer.y = pY - Math.sin(activeTrailer.angle) * (activeTrailer.w / 2 - 33.75); 
    }
    updateForklift(); camera.x = tractor.x; camera.y = tractor.y;
}

function startLevel3() { alert("Transitioning to Level 3!"); }

canvas.addEventListener('pointerdown', (e) => {
    if (!isEditMode) return;
    let mx = (e.clientX - canvas.width / 2) / currentZoom + camera.x, my = (e.clientY - canvas.height / 2) / currentZoom + camera.y;
    if (Math.sqrt((mx - junctionHandleLeft.x)**2 + (my - junctionHandleLeft.y)**2) < 80) { activeEditTarget = junctionHandleLeft; return; }
    if (Math.sqrt((mx - junctionHandleRight.x)**2 + (my - junctionHandleRight.y)**2) < 80) { activeEditTarget = junctionHandleRight; return; }
    for(let tree of trees) { if (Math.sqrt((mx - tree.x)**2 + (my - tree.y)**2) < 40) { activeEditTarget = tree; return; } }
});
canvas.addEventListener('pointermove', (e) => {
    if (!activeEditTarget || !isEditMode) return;
    let mx = (e.clientX - canvas.width / 2) / currentZoom + camera.x, my = (e.clientY - canvas.height / 2) / currentZoom + camera.y;
    activeEditTarget.x = mx; activeEditTarget.y = my;
});
canvas.addEventListener('pointerup', () => activeEditTarget = null);

function draw() {
    ctx.clearRect(0,0, canvas.width, canvas.height); ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2); ctx.rotate(-tractor.angle - Math.PI/2); ctx.scale(currentZoom, currentZoom); ctx.translate(-camera.x, -camera.y);
    ctx.fillStyle = "#2d613e"; ctx.fillRect(-50000, -50000, 100000, 100000);
    trees.forEach(t => drawTree(t)); 
    let mainY = getRoadY(initialExitX); 
    drawConstructionSiteDetails();
    ctx.fillStyle = "#555"; ctx.beginPath(); ctx.rect(gravelRoadX - roadWidth/2, mainY - gravelRoadLength, roadWidth, gravelRoadLength); ctx.fill();
    ctx.fillStyle = "#333"; ctx.beginPath();
    for (let x = -25000; x < 25000; x += 5) { let y = getRoadY(x); if (x === -25000) ctx.moveTo(x, y); else ctx.lineTo(x, y); }
    for (let x = 25000; x >= -25000; x -= 5) { let y = getRoadY(x) + roadWidth; ctx.lineTo(x, y); }
    ctx.fill(); ctx.strokeStyle = "#ffd700"; ctx.lineWidth = 6; ctx.setLineDash([40, 40]); ctx.beginPath();
    for (let x = -25000; x < 25000; x += 5) { let y = getRoadY(x) + roadWidth/2; if (x === -25000) ctx.moveTo(x, y); else ctx.lineTo(x, y); }
    ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle = "#333";
    ctx.fillRect(siteLocationX - roadWidth/2, getRoadY(siteLocationX) + roadWidth, roadWidth, lumberRoadLength);
    drawLumberYardGround(); 
    drawRealisticOffice(remoteLumberYard.x + 600, remoteLumberYard.y + remoteLumberYard.h - 250, 800, 500);
    const carColors = ["#cc0000", "#333333", "#ffffff", "#0000aa", "#555555"];
    const carW = 67.5, carH = 135; 
    for(let i=0; i<5; i++) {
        ctx.save(); ctx.translate(remoteLumberYard.x + 250 + (i * 135), remoteLumberYard.y + remoteLumberYard.h - 600);
        ctx.fillStyle = carColors[i]; ctx.fillRect(-carW/2, -carH/2, carW, carH);
        ctx.fillStyle = "#000"; ctx.fillRect(-carW/2 - 3, -carH/4, 5, 30); ctx.fillRect(carW/2 - 2, -carH/4, 5, 30);
        ctx.fillStyle = "rgba(135, 206, 235, 0.7)"; ctx.fillRect(-carW/2 + 8, -carH/4, carW - 16, 25); ctx.restore();
    }
    ctx.fillStyle = "rgba(255, 255, 255, 0.15)"; ctx.fillRect(loadingZone.x, loadingZone.y, loadingZone.w, loadingZone.h);
    drawConstructionSign(gravelRoadX + roadWidth/2 + 400, mainY - 500);
    lumberStacks.forEach(s => { if(s.exists) { drawLumberLift(s.x, s.y, s.w, s.h); } });
    drawForklift(forklift.x, forklift.y, forklift.angle);
    drawTruckDetailed(tractor.x, tractor.y, tractor.angle, true);
    if (activeTrailer) drawTrailerStatic(activeTrailer.x, activeTrailer.y, activeTrailer.angle, activeTrailer.type);
    ctx.restore(); update(); requestAnimationFrame(draw);
}

startBtn.onclick = (e) => { e.preventDefault(); if (truckDamage >= 100 || isRepairing) return; engineOn = !engineOn; timerStarted = true; startBtn.classList.toggle("on"); startBtn.innerText = engineOn ? "STOP" : "START"; };
document.getElementById("btnView").onclick = (e) => { e.preventDefault(); currentZoom = (currentZoom === 0.35 ? 0.15 : 0.35); };
const upBtn = document.getElementById("btnUp"), downBtn = document.getElementById("btnDown");
upBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); touch.up = true; }); upBtn.addEventListener('pointerup', (e) => { e.preventDefault(); touch.up = false; });
downBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); touch.down = true; }); downBtn.addEventListener('pointerup', (e) => { e.preventDefault(); touch.down = false; });
function processSteering(e) { 
    const rect = padEl.getBoundingClientRect();
    let sInput = (e.clientX - (rect.left + rect.width / 2)) / (rect.width / 2);
    sInput = Math.max(-1, Math.min(1, sInput));
    tractor.steerAngle = sInput * 0.6; wheelEl.style.transform = `translateX(${sInput * 50}px)`;
}
padEl.addEventListener('pointerdown', (e) => { e.preventDefault(); isSteeringActive = true; padEl.setPointerCapture(e.pointerId); processSteering(e); });
padEl.addEventListener('pointermove', (e) => { if (padEl.hasPointerCapture(e.pointerId)) processSteering(e); });
padEl.addEventListener('pointerup', (e) => { e.preventDefault(); isSteeringActive = false; wheelEl.style.transform = `translateX(0px)`; });
window.addEventListener('keydown', (e) => { if (keys.hasOwnProperty(e.code)) keys[e.code] = true; });
window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.code)) keys[e.code] = false; });
draw();
</script>
</body>
</html>
