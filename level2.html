<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Remi's Semi - Level 2 (Layout Adjusted)</title>
    <style>
        body { margin: 0; background: #2d613e; font-family: 'Segoe UI', sans-serif; overflow: hidden; color: white; touch-action: none; height: 100vh; width: 100vw; -webkit-user-select: none; user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; }
        #model-name { position: absolute; top: 5px; right: 10px; color: rgba(255,255,255,0.3); font-size: 10px; z-index: 20; }
        #dashboard { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 10; pointer-events: none; text-align: center; width: 100%; }
        #msg { font-size: 16px; color: #ffd700; text-shadow: 2px 2px #000; font-weight: bold; margin-bottom: 5px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 15px; display: inline-block; width: 94%; line-height: 1.2; box-sizing: border-box; border: 1px solid #444; transition: background 0.2s; }
        #gps-screen { position: absolute; bottom: 454px; left: 50%; transform: translateX(-50%); width: 90px; height: 30px; background: rgba(0,0,0,0.8); border: 2px solid #ffd700; border-radius: 5px; color: #ffd700; font-family: 'Courier New', monospace; font-weight: bold; font-size: 14px; z-index: 20; pointer-events: none; display: flex; align-items: center; justify-content: center; text-align: center; box-shadow: 0 0 10px rgba(0,0,0,0.5); line-height: 1.1; padding: 2px; box-sizing: border-box; }
        #msg.warning { background: rgba(200,0,0,0.9); color: white; border: 2px solid #ff0000; }
        #msg.repair { background: rgba(255,140,0,0.9); color: white; border: 2px solid #ffae00; }
        #bottom-stats { display: flex; justify-content: space-between; align-items: center; padding: 0 3%; margin-top: 5px; pointer-events: auto; }
        .stat-box { background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 5px; border: 1px solid #444; font-family: monospace; font-size: 16px; pointer-events: none; }
        #btnBackToStart { width: 35px; height: 35px; border-radius: 50%; background: #ffd700; color: #000; font-weight: bold; font-size: 20px; border: 2px solid #000; display: flex; align-items: center; justify-content: center; pointer-events: auto; cursor: pointer; text-decoration: none; position: absolute; top: 0; left: 10px; }
        #controls { position: absolute; bottom: 15px; width: 100%; display: flex; justify-content: space-between; align-items: flex-end; padding: 0 10px; box-sizing: border-box; z-index: 10; pointer-events: none; }
        .left-controls { display: flex; flex-direction: column; gap: 6px; align-items: flex-start; pointer-events: auto; }
        .pedal-box { display: flex; gap: 5px; }
        #steering-pad { width: 160px; height: 60px; background: transparent; border-radius: 30px; position: absolute; right: -20px; bottom: 96px; touch-action: none; pointer-events: auto; display: flex; align-items: center; justify-content: center; }
        #steering-wheel { width: 30px; height: 30px; background: #000; border: none; border-radius: 50%; box-sizing: border-box; position: relative; transition: transform 0.1s linear; box-shadow: 0 4px 10px rgba(0,0,0,0.5); pointer-events: none; }
        .btn { width: 55px; height: 48px; background: rgba(51,51,51,0.8); border: 2px solid #555; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 10px; color: white; user-select: none; pointer-events: auto; }
        #btnStart { background: rgba(80,0,0,0.8); border-color: #f00; height: 32px; font-weight: bold; }
        #btnStart.on { background: rgba(0,80,0,0.8); border-color: #0f0; }
        #btnView { height: 32px; font-size: 8px; background: rgba(0,100,200,0.8); }
        #btnSkip { height: 32px; font-size: 8px; background: rgba(128,0,128,0.8); border-color: #a020f0; }
        #btnSave { height: 32px; font-size: 8px; background: rgba(0,150,0,0.8); border-color: #0f0; }
        #victory-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        #victory-overlay h1 { color: #ffd700; font-size: 32px; margin-bottom: 20px; text-shadow: 0 0 10px #ffd700; text-align: center; }
        .continue-btn { padding: 15px 30px; font-size: 18px; background: #ffd700; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; color: black; }
    </style>
</head>
<body oncontextmenu="return false;">

<div id="model-name">Model: Gemini 3 Flash</div>

<div id="dashboard">
    <div id="msg">MISSION: DRIVE TO THE LUMBER YARD AND DELIVER THE LOAD!</div>
    <div id="bottom-stats">
        <div class="stat-box" style="color:#33ccff;">TIME: <span id="timer">00:00</span></div>
        <div class="stat-box" style="color:#ff3333;">DMG: <span id="damage">0%</span></div>
        <div class="stat-box" style="color:#ff9900;">DIST: <span id="miles">0.0</span></div>
        <a href="index.html" id="btnBackToStart">?</a>
    </div>
</div>

<div id="gps-screen">STRAIGHT</div>

<div id="victory-overlay">
    <h1 id="victory-msg">LOADED & READY!<br>LEVEL 2 COMPLETE</h1>
    <button class="continue-btn" onclick="startLevel3()">Head to Next Customer</button>
</div>

<canvas id="gameCanvas"></canvas>

<div id="controls">
    <div class="left-controls">
        <div class="pedal-box">
            <div id="btnDown" class="btn">REV</div>
            <div id="btnUp" class="btn">GAS</div>
        </div>
        <div style="display:flex; gap:4px; margin-top:4px;">
            <button id="btnStart" class="btn">START</button>
            <button id="btnView" class="btn">VIEW</button>
            <button id="btnSave" class="btn" onclick="toggleEditMode()">EDIT</button>
            <button id="btnDrop" class="btn" style="height:32px; font-size:8px; background:rgba(200,100,0,0.8);" onclick="handleHitch()">DROP/HOOK</button>
            <button id="btnSkip" class="btn" onclick="skipToGravel()">SKIP</button>
        </div>
    </div>
    <div id="steering-pad"><div id="steering-wheel"></div></div>
</div>

<script>
// ── getRoadY defined FIRST ────────────────────────────────────────────────
const roadBaseY     = 850;
const siteLocationX = 4000;
const roadWidth     = 254;
const lumberRoadLength = 1200;
let gravelRoadX      = parseFloat(localStorage.getItem('remiSemi_gravelRoadX')) || (siteLocationX - 8000);
const gravelRoadLength = 2000;

// Gravel road curve control points
let gravelRoadTopOffset = parseFloat(localStorage.getItem('remiSemi_gravelRoadTopOffset')) || 0;
let gravelRoadBottomOffset = parseFloat(localStorage.getItem('remiSemi_gravelRoadBottomOffset')) || 0;

function getRoadY(x) {
    if (x > siteLocationX - 1200) return roadBaseY;
    const targetY = roadBaseY + Math.sin(x / 1400) * 850;
    if (x > siteLocationX - 2500) {
        let weight = (x - (siteLocationX - 2500)) / 1300;
        return (targetY * (1 - weight)) + (roadBaseY * weight);
    }
    return targetY;
}

// ── DESTINATION: Level-2 lumber yard ─────────────────────────────────────
const remoteLumberYard = { x: siteLocationX - 1625, y: roadBaseY + roadWidth + lumberRoadLength, w: 3250, h: 3600 };
const loadingZone = {
    x: remoteLumberYard.x + (remoteLumberYard.w/2) - (roadWidth/2),
    y: remoteLumberYard.y + 550,
    w: roadWidth,
    h: 800
};

// ── BEGINNING YARD ────────────────────────────────────────────────────────
let startYardH = 1500;
let startYardW = 3250;
let startYardX, startYardY, startYard, startYardLZone;

function updateStartYardPositions() {
    startYardX = gravelRoadX - startYardW / 2;
    startYardY = getRoadY(gravelRoadX) - gravelRoadLength - startYardH;
    startYard  = { x: startYardX, y: startYardY, w: startYardW, h: startYardH };
    startYardLZone = {
        x: startYard.x + (startYard.w / 2) - (roadWidth / 2),
        y: startYard.y + (startYard.h / 2) - 400,
        w: roadWidth,
        h: 800
    };
}

updateStartYardPositions();

// ── Gravel road editing handles ───────────────────────────────────────────
let gravelRoadHandles = {
    center: { x: gravelRoadX, y: 0 },
    top: { x: gravelRoadX, y: 0 },
    bottom: { x: gravelRoadX, y: 0 }
};

function updateGravelRoadHandles() {
    const yardBottom = startYard.y + startYard.h;
    const mainRoadTop = getRoadY(gravelRoadX);
    const midY = (yardBottom + mainRoadTop) / 2;
    
    gravelRoadHandles.center.x = gravelRoadX;
    gravelRoadHandles.center.y = midY;
    
    gravelRoadHandles.top.x = gravelRoadX + gravelRoadTopOffset;
    gravelRoadHandles.top.y = yardBottom + 200;
    
    gravelRoadHandles.bottom.x = gravelRoadX + gravelRoadBottomOffset;
    gravelRoadHandles.bottom.y = mainRoadTop - 200;
}

// Function to draw curved gravel road
function drawCurvedGravelRoad(ctx) {
    const yardBottom = startYard.y + startYard.h;
    const mainRoadTop = getRoadY(gravelRoadX);
    
    // Calculate control points for bezier curve
    const startX = gravelRoadX;
    const startY = yardBottom;
    const endX = gravelRoadX;
    const endY = mainRoadTop;
    
    const cp1X = gravelRoadX + gravelRoadTopOffset;
    const cp1Y = yardBottom + (mainRoadTop - yardBottom) * 0.33;
    
    const cp2X = gravelRoadX + gravelRoadBottomOffset;
    const cp2Y = yardBottom + (mainRoadTop - yardBottom) * 0.67;
    
    // Draw the road using multiple segments
    ctx.fillStyle = "#555";
    
    for (let t = 0; t < 1; t += 0.01) {
        const t1 = 1 - t;
        const t2 = 1 - (t + 0.01);
        
        // Cubic bezier formula
        const x1 = t1*t1*t1*startX + 3*t1*t1*t*cp1X + 3*t1*t*t*cp2X + t*t*t*endX;
        const y1 = t1*t1*t1*startY + 3*t1*t1*t*cp1Y + 3*t1*t*t*cp2Y + t*t*t*endY;
        
        const x2 = t2*t2*t2*startX + 3*t2*t2*(t+0.01)*cp1X + 3*t2*(t+0.01)*(t+0.01)*cp2X + (t+0.01)*(t+0.01)*(t+0.01)*endX;
        const y2 = t2*t2*t2*startY + 3*t2*t2*(t+0.01)*cp1Y + 3*t2*(t+0.01)*(t+0.01)*cp2Y + (t+0.01)*(t+0.01)*(t+0.01)*endY;
        
        // Calculate perpendicular for road width
        const dx = x2 - x1;
        const dy = y2 - y1;
        const len = Math.sqrt(dx*dx + dy*dy);
        const perpX = -dy / len * roadWidth / 2;
        const perpY = dx / len * roadWidth / 2;
        
        ctx.beginPath();
        ctx.moveTo(x1 + perpX, y1 + perpY);
        ctx.lineTo(x1 - perpX, y1 - perpY);
        ctx.lineTo(x2 - perpX, y2 - perpY);
        ctx.lineTo(x2 + perpX, y2 + perpY);
        ctx.closePath();
        ctx.fill();
    }
}

// Check if point is on curved gravel road
function isOnCurvedGravelRoad(x, y) {
    const yardBottom = startYard.y + startYard.h;
    const mainRoadTop = getRoadY(gravelRoadX);
    
    if (y < yardBottom || y > mainRoadTop) return false;
    
    const startX = gravelRoadX;
    const startY = yardBottom;
    const endX = gravelRoadX;
    const endY = mainRoadTop;
    
    const cp1X = gravelRoadX + gravelRoadTopOffset;
    const cp1Y = yardBottom + (mainRoadTop - yardBottom) * 0.33;
    
    const cp2X = gravelRoadX + gravelRoadBottomOffset;
    const cp2Y = yardBottom + (mainRoadTop - yardBottom) * 0.67;
    
    // Check multiple points along the curve
    for (let t = 0; t <= 1; t += 0.02) {
        const t1 = 1 - t;
        const curveX = t1*t1*t1*startX + 3*t1*t1*t*cp1X + 3*t1*t*t*cp2X + t*t*t*endX;
        const curveY = t1*t1*t1*startY + 3*t1*t1*t*cp1Y + 3*t1*t*t*cp2Y + t*t*t*endY;
        
        const dist = Math.sqrt((x - curveX)**2 + (y - curveY)**2);
        if (dist < roadWidth / 2) return true;
    }
    
    return false;
}

let startYardStacks = [];

function rebuildStartYardStacks() {
    startYardStacks = [];
    let leftConsumed = 0, rightConsumed = 0;
    for (let i = 0; i < 12; i++) {
        for (let j = 0; j < 2; j++) {
            const leftExists = leftConsumed < 6 ? false : true;
            if (leftConsumed < 6) leftConsumed++;
            startYardStacks.push({
                x: startYardLZone.x - 210 - (j+1)*100,
                y: startYardLZone.y - 220 + i*70,
                exists: leftExists,
                pile: 'left'
            });

            const rightExists = rightConsumed < 6 ? false : true;
            if (rightConsumed < 6) rightConsumed++;
            startYardStacks.push({
                x: startYardLZone.x + startYardLZone.w + 110 + (j+1)*100,
                y: startYardLZone.y - 220 + i*70,
                exists: rightExists,
                pile: 'right'
            });
        }
    }
}

rebuildStartYardStacks();

let startYardCars = [];
function rebuildStartYardCars() {
    startYardCars = [];
    for (let i = 0; i < 6; i++) {
        startYardCars.push({
            x: startYard.x + 100 + (i * 80),
            y: startYard.y + 150,
            color: ['#c0c0c0','#444','#fff','#003366','#800000'][i % 5]
        });
    }
}
rebuildStartYardCars();

let turnRadius = parseFloat(localStorage.getItem('remiSemi_turnRadius')) || 450;
let isEditMode = false;
let junctionHandleLeft  = { x: gravelRoadX - roadWidth/2 - turnRadius, y: 0 };
let junctionHandleRight = { x: gravelRoadX + roadWidth/2 + turnRadius, y: 0 };
let activeEditTarget = null;
const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

const SPAWN_ANGLE = Math.PI / 2;
let SPAWN_X, SPAWN_Y;

function updateSpawnPosition() {
    SPAWN_X = startYardLZone.x + startYardLZone.w / 2;
    SPAWN_Y = startYardLZone.y + startYardLZone.h - 200;
}
updateSpawnPosition();

function skipToGravel() {
    tractor.x = siteLocationX;
    tractor.y = roadBaseY + roadWidth + 50;
    tractor.angle = Math.PI / 2;
    tractor.speed = 0;
    truckDamage = 0;
    recoveryTimer = 0;
    if (activeTrailer) {
        activeTrailer.angle = tractor.angle;
        activeTrailer.x = tractor.x - Math.cos(tractor.angle) * 440;
        activeTrailer.y = tractor.y - Math.sin(tractor.angle) * 440;
    }
}

function toggleEditMode() {
    const btn = document.getElementById("btnSave");
    const msgBox = document.getElementById("msg");
    if (!isEditMode) {
        isEditMode = true;
        btn.innerText = "SAVE";
        btn.style.background = "rgba(200,0,0,0.8)";
        msgBox.innerText = "EDIT MODE: DRAG HANDLES TO SHAPE GRAVEL ROAD CURVE";
    } else {
        isEditMode = false;
        btn.innerText = "EDIT";
        btn.style.background = "rgba(0,150,0,0.8)";
        localStorage.setItem('remiSemi_turnRadius', turnRadius);
        localStorage.setItem('remiSemi_gravelRoadX', gravelRoadX);
        localStorage.setItem('remiSemi_gravelRoadTopOffset', gravelRoadTopOffset);
        localStorage.setItem('remiSemi_gravelRoadBottomOffset', gravelRoadBottomOffset);
        localStorage.setItem('remiSemi_trees', JSON.stringify(trees));
        msgBox.innerText = "LAYOUT SAVED!";
        setTimeout(() => { msgBox.innerText = "MISSION: DRIVE TO THE LUMBER YARD AND DELIVER THE LOAD!"; }, 2000);
    }
}

let dustParticles = [];
function createDust(x, y) {
    if (Math.abs(tractor.speed) < 1) return;
    dustParticles.push({ x, y, size: 5 + Math.random()*15, alpha: 0.6, life: 1.0 });
}

let timeElapsed = 0, totalDistance = 0, gameActive = true, timerStarted = false;
let liftsLoaded = 12;
let truckDamage = 0, accidents = 0;
let isRepairing = false, repairTimer = 0;
let offRoadTimer = 0, recoveryTimer = 0, gracePeriod = 0;
let serviceTruck = { x: 0, y: 0, angle: 0, active: false, flashState: false };

let lumberStacks = [];
for(let side = 0; side < 2; side++) {
    let baseSideX = side === 0 ? -750 : 450;
    for(let block = 0; block < 3; block++) {
        let blockYOffset = block * 450;
        for(let row = 0; row < 3; row++) {
            for(let col = 0; col < 4; col++) {
                lumberStacks.push({
                    x: loadingZone.x + baseSideX + (col * 140),
                    y: (loadingZone.y + 100 + blockYOffset + (row * 80)) - 200,
                    w: 120, h: 60, exists: true
                });
            }
        }
    }
}

let forklift = {
    x: loadingZone.x - 350, y: loadingZone.y + 250,
    angle: Math.PI, state: "idle", carrying: false,
    path: [], pathIndex: 0, speed: 7
};

const savedTrees = localStorage.getItem('remiSemi_trees');
let trees = savedTrees ? JSON.parse(savedTrees) : [];
if (trees.length === 0) {
    for(let i = 0; i < 100; i++) {
        let tx = (Math.random() - 0.5) * 15000 + 2000;
        let ty = (Math.random() - 0.5) * 10000 + 1000;
        if (Math.sqrt((tx-loadingZone.x)**2+(ty-loadingZone.y)**2) > 1000)
            trees.push({ x: tx, y: ty, size: 40+Math.random()*30, rotation: Math.random()*Math.PI*2 });
    }
}

const canvas = document.getElementById("gameCanvas"), ctx = canvas.getContext("2d");
const padEl = document.getElementById("steering-pad"), wheelEl = document.getElementById("steering-wheel"), startBtn = document.getElementById("btnStart");

let engineOn = false;
const touch = { up: false, down: false };
let currentZoom = 0.35;

const tractor = {
    x: SPAWN_X, y: SPAWN_Y,
    w: 292.5, h: 67.5,
    angle: SPAWN_ANGLE,
    speed: 0, accel: 0.05, revAccel: 0.04, friction: 0.98, steerAngle: 0
};
const camera = { x: 0, y: 0 };

const TRAILER_W = 550, TRAILER_H = 92;
let hitchX = SPAWN_X - Math.cos(SPAWN_ANGLE) * 101.25;
let hitchY = SPAWN_Y - Math.sin(SPAWN_ANGLE) * 101.25;
let trailerCX = hitchX - Math.cos(SPAWN_ANGLE) * (TRAILER_W / 2 - 33.75);
let trailerCY = hitchY - Math.sin(SPAWN_ANGLE) * (TRAILER_W / 2 - 33.75);

let allTrailers = [{
    x: trailerCX, y: trailerCY,
    w: TRAILER_W, h: TRAILER_H,
    angle: SPAWN_ANGLE, type: 'flatbed'
}];
let activeTrailer = allTrailers[0];
let isSteeringActive = false;

let startForkliftX, startForkliftY;
const startForkliftAngle   = 0;
const startForkliftCarrying = false;

function updateStartForkliftPosition() {
    startForkliftX = startYardLZone.x - 200;
    startForkliftY = startYardLZone.y + 400;
}
updateStartForkliftPosition();

const timerInterval = setInterval(() => {
    if (!gameActive || !timerStarted) return;
    timeElapsed++;
    if (isRepairing) {
        repairTimer--;
        serviceTruck.flashState = !serviceTruck.flashState;
        if (repairTimer <= 0) {
            isRepairing = false; serviceTruck.active = false;
            truckDamage = Math.max(0, truckDamage - 30);
            document.getElementById("msg").classList.remove("repair");
            gracePeriod = 10; startBtn.innerText = "START";
        }
    }
    if (recoveryTimer > 0) { recoveryTimer--; if (recoveryTimer <= 0) gracePeriod = 10; }
    if (gracePeriod > 0) gracePeriod--;
    const mins = Math.floor(timeElapsed/60), secs = timeElapsed%60;
    document.getElementById("timer").innerText = `${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
}, 1000);

function handleHitch() {
    if (activeTrailer) activeTrailer = null;
    else allTrailers.forEach(t => { if (Math.sqrt((tractor.x-t.x)**2+(tractor.y-t.y)**2) < 300) activeTrailer = t; });
}

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();

// Convert screen coordinates to world coordinates
function screenToWorld(screenX, screenY) {
    let x = screenX - canvas.width / 2;
    let y = screenY - canvas.height / 2;
    x = x / currentZoom;
    y = y / currentZoom;
    const angle = tractor.angle + Math.PI / 2;
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const rotX = x * cos - y * sin;
    const rotY = x * sin + y * cos;
    return {
        x: rotX + camera.x,
        y: rotY + camera.y
    };
}

function drawTree(t) {
    ctx.save(); ctx.translate(t.x,t.y); ctx.rotate(t.rotation);
    ctx.fillStyle="#1b4d2c"; ctx.beginPath(); ctx.arc(0,0,t.size,0,Math.PI*2); ctx.fill();
    ctx.restore();
}

function drawLumberLift(x, y, w, h) {
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle="#e3c5a8"; ctx.fillRect(0,0,w,h);
    ctx.strokeStyle="#8b4513"; ctx.lineWidth=2; ctx.strokeRect(0,0,w,h);
    ctx.save(); ctx.clip();
    for(let i=0;i<h;i+=4){ ctx.fillStyle="rgba(0,0,0,0.05)"; ctx.fillRect(0,i+3,w,1); }
    ctx.restore();
    ctx.fillStyle="#111"; ctx.fillRect(w*0.2,0,3,h); ctx.fillRect(w*0.8,0,3,h);
    ctx.restore();
}

function drawOfficeSimple(x, y) {
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle="rgba(0,0,0,0.3)"; ctx.fillRect(-5,-5,410,210);
    ctx.fillStyle="#546e7a"; ctx.fillRect(0,0,400,200);
    ctx.strokeStyle="#263238"; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(0,100); ctx.lineTo(400,100); ctx.stroke();
    ctx.fillStyle="rgba(0,0,0,0.1)"; ctx.fillRect(0,100,400,100);
    ctx.fillStyle="#333"; ctx.fillRect(320,40,30,30);
    ctx.restore();
}

function drawCar(x, y, color, angle=0) {
    ctx.save(); ctx.translate(x,y); ctx.rotate(angle);
    ctx.fillStyle="rgba(0,0,0,0.2)"; ctx.fillRect(-32,-19,64,38);
    ctx.fillStyle=color; ctx.fillRect(-30,-17.5,60,35);
    ctx.fillStyle="#333"; ctx.fillRect(5,-14,15,28);
    ctx.fillStyle="#fff"; ctx.fillRect(26,-15,4,8); ctx.fillRect(26,7,4,8);
    ctx.fillStyle="#111"; ctx.fillRect(-20,-19.5,12,4); ctx.fillRect(10,-19.5,12,4);
    ctx.fillRect(-20,15.5,12,4); ctx.fillRect(10,15.5,12,4);
    ctx.restore();
}

function drawForkliftL1(x, y, angle, carrying) {
    ctx.save(); ctx.translate(x,y); ctx.rotate(angle);
    ctx.fillStyle="#e67e22"; ctx.fillRect(-30,-20,60,40);
    ctx.fillStyle="#333"; ctx.fillRect(-35,-20,15,40);
    ctx.fillStyle="#222"; ctx.fillRect(30,-18,5,36);
    ctx.fillStyle="#777"; ctx.fillRect(35,-15,45,4); ctx.fillRect(35,11,45,4);
    ctx.fillStyle="#000"; ctx.fillRect(10,-23,15,6); ctx.fillRect(10,17,15,6);
    ctx.fillRect(-25,-23,12,6); ctx.fillRect(-25,17,12,6);
    if (carrying) { drawLumberLift(35,-15,40,30); }
    ctx.restore();
}

function drawForklift(x, y, angle) {
    ctx.save(); ctx.translate(x,y); ctx.rotate(angle);
    ctx.fillStyle="#e67e22"; ctx.fillRect(-40,-25,80,50);
    ctx.fillStyle="#333"; ctx.fillRect(40,-22,10,44);
    ctx.fillRect(50,-20,40,5); ctx.fillRect(50,15,40,5);
    if (forklift.carrying) { ctx.fillStyle="#d2b48c"; ctx.fillRect(55,-30,60,60); }
    ctx.fillStyle="#111";
    ctx.fillRect(-35,-28,20,8); ctx.fillRect(-35,20,20,8);
    ctx.fillRect(25,-28,15,8); ctx.fillRect(25,20,15,8);
    ctx.restore();
}

function drawRealisticOffice(x, y, w, h) {
    ctx.save(); ctx.translate(x,y); ctx.rotate(Math.PI);
    ctx.shadowBlur=15; ctx.shadowColor="rgba(0,0,0,0.5)"; ctx.shadowOffsetY=10;
    const roofGrd=ctx.createLinearGradient(-w/2,-h/2,w/2,-h/2);
    roofGrd.addColorStop(0,"#444"); roofGrd.addColorStop(0.5,"#666"); roofGrd.addColorStop(1,"#444");
    ctx.fillStyle=roofGrd; ctx.fillRect(-w/2,-h/2,w,h);
    ctx.shadowBlur=0; ctx.shadowOffsetY=0;
    ctx.strokeStyle="rgba(255,255,255,0.08)"; ctx.lineWidth=2;
    for(let i=-w/2;i<w/2;i+=15){ ctx.beginPath(); ctx.moveTo(i,-h/2); ctx.lineTo(i,h/2); ctx.stroke(); }
    ctx.fillStyle="rgba(0,0,0,0.3)"; ctx.fillRect(-w/2+50,-h/2+50,w-100,h-100);
    ctx.fillStyle="#ffcc00"; ctx.font="bold 40px Arial"; ctx.textAlign="center";
    ctx.fillText("YARD OFFICE",0,15);
    ctx.restore();
}

function drawLumberYardGround() {
    ctx.save(); ctx.translate(remoteLumberYard.x,remoteLumberYard.y);
    ctx.fillStyle="#555"; ctx.fillRect(0,0,remoteLumberYard.w,remoteLumberYard.h);
    ctx.strokeStyle="#fff"; ctx.lineWidth=10; ctx.strokeRect(0,0,remoteLumberYard.w,remoteLumberYard.h);
    ctx.strokeStyle="#ffd700"; ctx.lineWidth=8; ctx.setLineDash([20,15]);
    ctx.strokeRect(loadingZone.x-remoteLumberYard.x-10, loadingZone.y-remoteLumberYard.y-10, loadingZone.w+20, loadingZone.h+20);
    ctx.setLineDash([]);
    ctx.save();
    ctx.translate(loadingZone.x-remoteLumberYard.x+loadingZone.w/2, loadingZone.y-remoteLumberYard.y+loadingZone.h/2);
    ctx.rotate(Math.PI);
    ctx.fillStyle="rgba(255,215,0,0.4)"; ctx.font="bold 60px Arial"; ctx.textAlign="center";
    ctx.fillText("LOADING",0,-15); ctx.fillText("ZONE",0,55);
    ctx.restore(); ctx.restore();
}

function drawConstructionSign(x, y) {
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle="#444"; ctx.fillRect(-5,0,10,80);
    ctx.fillStyle="#ff8800"; ctx.strokeStyle="white"; ctx.lineWidth=4;
    ctx.fillRect(-100,-60,200,80); ctx.strokeRect(-100,-60,200,80);
    ctx.fillStyle="black"; ctx.font="bold 18px Arial"; ctx.textAlign="center";
    ctx.fillText("CONSTRUCTION",0,-30); ctx.fillText("SITE",0,-5);
    ctx.restore();
}

function drawEditHandle(x, y, label, color = "#00ffff", size = 40) {
    ctx.fillStyle = color;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(x - size * 0.6, y);
    ctx.lineTo(x + size * 0.6, y);
    ctx.moveTo(x, y - size * 0.6);
    ctx.lineTo(x, y + size * 0.6);
    ctx.stroke();
    
    if (label) {
        ctx.fillStyle = "#000000";
        ctx.font = "bold 24px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(label, x, y);
    }
}

function drawTrailerStatic(x, y, angle, type) {
    const th=92, tw=550;
    ctx.save(); ctx.translate(x,y); ctx.rotate(angle);
    ctx.fillStyle="rgba(0,0,0,0.5)"; ctx.fillRect(-tw/2+5,-th/2+5,tw,th);
    for(let i=-th/2;i<th/2;i+=8){ ctx.fillStyle=(Math.floor(i/8)%2===0)?"#5d4037":"#4a352f"; ctx.fillRect(-tw/2,i,tw,8); }
    ctx.fillStyle="#b0b0b0"; ctx.fillRect(-tw/2,-th/2,tw,6); ctx.fillRect(-tw/2,th/2-6,tw,6);
    for(let i=-tw/2;i<tw/2;i+=20){ ctx.fillStyle=(Math.floor(i/20)%2===0)?"#d32f2f":"#ffffff"; ctx.fillRect(i,-th/2+1,10,2); ctx.fillRect(i,th/2-3,10,2); }
    ctx.fillStyle="#1a1a1a";
    for(let i=-tw/2+15;i<tw/2;i+=40){ ctx.fillStyle=(Math.floor(i/40)%2===0)?"#d32f2f":"#ffffff"; ctx.fillRect(i,-th/2,8,3); ctx.fillRect(i,th/2-3,8,3); }
    for(let i=0;i<liftsLoaded;i++){
        let col=i%6, row=(i<6)?0:1;
        drawLumberLift(-tw/2+20+col*80, -th/2+10+(row*35), 70, 30);
    }
    ctx.strokeStyle="#ffd700"; ctx.lineWidth=3;
    for(let i=-tw/2+55;i<tw/2-50;i+=80){ ctx.beginPath(); ctx.moveTo(i,th/2-6); ctx.lineTo(i,-th/2+6); ctx.stroke(); }
    ctx.fillStyle="#000"; ctx.fillRect(-tw/2+40,-th/2-5,60,10); ctx.fillRect(-tw/2+40,th/2-5,60,10);
    ctx.fillStyle="#333"; ctx.fillRect(-tw/2,-th/2,5,th);
    ctx.restore();
}

function drawTruckDetailed(x, y, angle, isSteering=false, cabColor="#800000") {
    ctx.save(); ctx.translate(x,y); ctx.rotate(angle);
    if (gracePeriod>0) ctx.globalAlpha=0.6;
    const s=2.25;
    ctx.fillStyle="#111";
    ctx.fillRect((-130*s)/2,(-30*s)/6,(130*s)-(50*s),(30*s)/3);
    ctx.fillRect(0,(-30*s)/2,60*s,30*s);
    ctx.fillStyle="#000";
    ctx.fillRect(-62*s,-12*s,12*s,6*s); ctx.fillRect(-62*s,6*s,12*s,6*s);
    ctx.fillRect(-45*s,-12*s,12*s,6*s); ctx.fillRect(-45*s,6*s,12*s,6*s);
    ctx.save(); ctx.translate(46*s,(-30*s)/2+0.5); if(isSteering) ctx.rotate(tractor.steerAngle); ctx.fillRect(-6*s,-2.5*s,12*s,5*s); ctx.restore();
    ctx.save(); ctx.translate(46*s,(30*s)/2-0.5); if(isSteering) ctx.rotate(tractor.steerAngle); ctx.fillRect(-6*s,-2.5*s,12*s,5*s); ctx.restore();
    ctx.fillStyle=cabColor;
    ctx.fillRect(-10*s,(-30*s)/2,40*s,30*s);
    ctx.fillRect(30*s,(-30*s)/2+4*s,30*s,(30*s)-8*s);
    ctx.fillStyle="#777"; ctx.fillRect(-12*s,(-30*s)/2-5*s,6*s,6*s); ctx.fillRect(-12*s,(30*s)/2-1*s,6*s,6*s);
    ctx.fillStyle="#FFD700"; for(let i=0;i<4;i++){ctx.fillRect(27*s,(-30*s)/2+4*s+(i*6.5*s),3*s,3*s);}
    ctx.fillStyle="#aaa"; ctx.fillRect(30*s,(-30*s)/2-4*s,4*s,5*s); ctx.fillRect(30*s,(30*s)/2-1*s,4*s,5*s);
    const bumperGrd=ctx.createLinearGradient(58*s,0,65*s,0);
    bumperGrd.addColorStop(0,"#888"); bumperGrd.addColorStop(0.5,"#eee"); bumperGrd.addColorStop(1,"#999");
    ctx.fillStyle=bumperGrd; ctx.fillRect(58*s,(-30*s)/2-1,5*s,30*s+2);
    ctx.restore();
}

function planProfessionalLoad() {
    if (!activeTrailer||liftsLoaded>=12) return;
    let col=liftsLoaded%6;
    let stack=lumberStacks.find(s=>s.exists);
    if (!stack) return;
    const stopOffset=-85;
    let cos=Math.cos(activeTrailer.angle), sin=Math.sin(activeTrailer.angle);
    let dropOffsetX=-activeTrailer.w/2+60+(col*85), dropOffsetY=stopOffset;
    let dropX=activeTrailer.x+(dropOffsetX*cos-dropOffsetY*sin);
    let dropY=activeTrailer.y+(dropOffsetX*sin+dropOffsetY*cos);
    let approachOffsetY=stopOffset-300;
    let approachX=activeTrailer.x+(dropOffsetX*cos-approachOffsetY*sin);
    let approachY=activeTrailer.y+(dropOffsetX*sin+approachOffsetY*cos);
    let rearWayoffsetX=-activeTrailer.w/2-200, rearWayoffsetY=stopOffset-300;
    let rearWayX=activeTrailer.x+(rearWayoffsetX*cos-rearWayoffsetY*sin);
    let rearWayY=activeTrailer.y+(rearWayoffsetX*sin+rearWayoffsetY*cos);
    forklift.path=[]; forklift.pathIndex=0;
    forklift.path.push({x:stack.x+150,y:stack.y,ang:0,act:'move'});
    forklift.path.push({x:stack.x,y:stack.y,ang:0,act:'grab'});
    forklift.path.push({x:stack.x+150,y:stack.y,ang:0,act:'move'});
    forklift.path.push({x:rearWayX,y:rearWayY,ang:activeTrailer.angle,act:'move'});
    forklift.path.push({x:approachX,y:approachY,ang:activeTrailer.angle+Math.PI/2,act:'move'});
    forklift.path.push({x:dropX,y:dropY,ang:activeTrailer.angle+Math.PI/2,act:'drop'});
    forklift.path.push({x:approachX,y:approachY,ang:activeTrailer.angle+Math.PI/2,act:'move'});
    forklift.path.push({x:rearWayX,y:rearWayY,ang:activeTrailer.angle,act:'move'});
    forklift.state="moving";
}

function updateForklift() {
    if (forklift.state==="idle"&&activeTrailer) {
        let cx=activeTrailer.x, cy=activeTrailer.y;
        if (cx>loadingZone.x&&cx<loadingZone.x+loadingZone.w&&cy>loadingZone.y&&cy<loadingZone.y+loadingZone.h&&Math.abs(tractor.speed)<0.1)
            planProfessionalLoad();
    }
    if (forklift.path.length>0&&forklift.pathIndex<forklift.path.length) {
        let target=forklift.path[forklift.pathIndex];
        let dx=target.x-forklift.x, dy=target.y-forklift.y, dist=Math.sqrt(dx*dx+dy*dy);
        if (dist>5) {
            forklift.x+=(dx/dist)*forklift.speed; forklift.y+=(dy/dist)*forklift.speed;
            let ad=target.ang-forklift.angle;
            while(ad>Math.PI)ad-=Math.PI*2; while(ad<-Math.PI)ad+=Math.PI*2;
            forklift.angle+=ad*0.1;
        } else {
            if(target.act==='grab'){forklift.carrying=true;let s=lumberStacks.find(s=>s.exists);if(s)s.exists=false;}
            else if(target.act==='drop'){forklift.carrying=false;liftsLoaded++;if(liftsLoaded>=12){gameActive=false;document.getElementById("victory-overlay").style.display="flex";}}
            forklift.pathIndex++;
            if(forklift.pathIndex>=forklift.path.length)forklift.state="idle";
        }
    }
}

function update() {
    if (!gameActive) return;
    if (isRepairing) {
        tractor.speed*=0.8;
        let dx=(tractor.x-Math.cos(tractor.angle+0.5)*150)-serviceTruck.x;
        let dy=(tractor.y-Math.sin(tractor.angle+0.5)*150)-serviceTruck.y;
        serviceTruck.x+=dx*0.05; serviceTruck.y+=dy*0.05; return;
    }
    if (recoveryTimer>0){ tractor.speed*=0.8; return; }
    if (truckDamage>=100){ engineOn=false; startBtn.classList.remove("on"); startBtn.innerText="TOTALED"; }
    if (engineOn) {
        if(touch.up||keys.ArrowUp) tractor.speed+=tractor.accel;
        if(touch.down||keys.ArrowDown) tractor.speed-=tractor.revAccel;
    }
    tractor.speed*=tractor.friction;
    if (!isSteeringActive) {
        if(keys.ArrowLeft){tractor.steerAngle=-0.6;wheelEl.style.transform=`translateX(-50px)`;}
        else if(keys.ArrowRight){tractor.steerAngle=0.6;wheelEl.style.transform=`translateX(50px)`;}
        else{tractor.steerAngle+=(0-tractor.steerAngle)*0.12;if(Math.abs(tractor.steerAngle)<0.001){tractor.steerAngle=0;wheelEl.style.transform=`translateX(0px)`;}}
    }
    document.getElementById("miles").innerText=(Math.sqrt((tractor.x-loadingZone.x)**2+(tractor.y-loadingZone.y)**2)/1000).toFixed(1);
    tractor.angle+=(tractor.speed/120)*Math.tan(tractor.steerAngle*1.0);
    tractor.x+=Math.cos(tractor.angle)*tractor.speed;
    tractor.y+=Math.sin(tractor.angle)*tractor.speed;

    const gps=document.getElementById("gps-screen");
    let mainY=getRoadY(gravelRoadX);
    if(tractor.x<gravelRoadX+300&&tractor.y<mainY)gps.innerText="LEFT";
    else if(tractor.y<mainY&&tractor.x>siteLocationX-500)gps.innerText="RIGHT";
    else gps.innerText="STRAIGHT";

    let offRoad=true;
    let cry=getRoadY(tractor.x);
    if(tractor.y>cry&&tractor.y<cry+roadWidth) offRoad=false;
    if(tractor.x>siteLocationX-roadWidth/2&&tractor.x<siteLocationX+roadWidth/2&&tractor.y>cry&&tractor.y<cry+roadWidth+lumberRoadLength) offRoad=false;
    if(tractor.x>remoteLumberYard.x&&tractor.x<remoteLumberYard.x+remoteLumberYard.w&&tractor.y>remoteLumberYard.y&&tractor.y<remoteLumberYard.y+remoteLumberYard.h) offRoad=false;
    if(tractor.x>startYard.x&&tractor.x<startYard.x+startYard.w&&tractor.y>startYard.y&&tractor.y<startYard.y+startYard.h) offRoad=false;
    if(isOnCurvedGravelRoad(tractor.x, tractor.y)) offRoad=false;

    dustParticles.forEach((p,i)=>{p.life-=0.02;p.alpha-=0.01;p.size+=0.5;if(p.life<=0)dustParticles.splice(i,1);});
    if(offRoad&&Math.abs(tractor.speed)>0.5){truckDamage+=0.05;offRoadTimer++;if(gracePeriod<=0)tractor.speed*=0.95;}
    if(gracePeriod<=0){
        trees.forEach(t=>{let dx=tractor.x-t.x,dy=tractor.y-t.y,dist=Math.sqrt(dx*dx+dy*dy);if(dist<t.size+30){truckDamage+=5;accidents++;tractor.speed=-tractor.speed*0.5;recoveryTimer=10;}});
    }
    document.getElementById("damage").innerText=Math.floor(Math.min(100,truckDamage))+"%";
    if(activeTrailer){
        const pX=tractor.x-Math.cos(tractor.angle)*101.25, pY=tractor.y-Math.sin(tractor.angle)*101.25;
        const dx=pX-activeTrailer.x, dy=pY-activeTrailer.y;
        activeTrailer.angle=Math.atan2(dy,dx);
        activeTrailer.x=pX-Math.cos(activeTrailer.angle)*(activeTrailer.w/2-33.75);
        activeTrailer.y=pY-Math.sin(activeTrailer.angle)*(activeTrailer.w/2-33.75);
    }
    updateForklift();
    updateGravelRoadHandles();
    camera.x=tractor.x; camera.y=tractor.y;
}

function startLevel3() { alert("Transitioning to Level 3!"); }

canvas.addEventListener('pointerdown',(e)=>{
    if(!isEditMode)return;
    
    const worldPos = screenToWorld(e.clientX, e.clientY);
    const mx = worldPos.x;
    const my = worldPos.y;
    
    // Check gravel road handles
    if(Math.sqrt((mx-gravelRoadHandles.center.x)**2+(my-gravelRoadHandles.center.y)**2)<150){
        activeEditTarget = { type: 'gravelCenter' };
        return;
    }
    if(Math.sqrt((mx-gravelRoadHandles.top.x)**2+(my-gravelRoadHandles.top.y)**2)<150){
        activeEditTarget = { type: 'gravelTop' };
        return;
    }
    if(Math.sqrt((mx-gravelRoadHandles.bottom.x)**2+(my-gravelRoadHandles.bottom.y)**2)<150){
        activeEditTarget = { type: 'gravelBottom' };
        return;
    }
    
    if(Math.sqrt((mx-junctionHandleLeft.x)**2+(my-junctionHandleLeft.y)**2)<80){activeEditTarget=junctionHandleLeft;return;}
    if(Math.sqrt((mx-junctionHandleRight.x)**2+(my-junctionHandleRight.y)**2)<80){activeEditTarget=junctionHandleRight;return;}
    for(let tree of trees){if(Math.sqrt((mx-tree.x)**2+(my-tree.y)**2)<40){activeEditTarget=tree;return;}}
});

canvas.addEventListener('pointermove',(e)=>{
    if(!activeEditTarget||!isEditMode)return;
    
    const worldPos = screenToWorld(e.clientX, e.clientY);
    const mx = worldPos.x;
    const my = worldPos.y;
    
    if (activeEditTarget.type === 'gravelCenter') {
        gravelRoadX = mx;
        updateStartYardPositions();
        rebuildStartYardStacks();
        rebuildStartYardCars();
        updateSpawnPosition();
        updateStartForkliftPosition();
        updateGravelRoadHandles();
    } else if (activeEditTarget.type === 'gravelTop') {
        gravelRoadTopOffset = mx - gravelRoadX;
        updateGravelRoadHandles();
    } else if (activeEditTarget.type === 'gravelBottom') {
        gravelRoadBottomOffset = mx - gravelRoadX;
        updateGravelRoadHandles();
    } else {
        activeEditTarget.x = mx; 
        activeEditTarget.y = my;
    }
});

canvas.addEventListener('pointerup',()=>activeEditTarget=null);

function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.translate(canvas.width/2,canvas.height/2);
    ctx.rotate(-tractor.angle-Math.PI/2);
    ctx.scale(currentZoom,currentZoom);
    ctx.translate(-camera.x,-camera.y);

    ctx.fillStyle="#2d613e"; ctx.fillRect(-50000,-50000,100000,100000);
    trees.forEach(t=>drawTree(t));

    ctx.fillStyle="#555";
    ctx.fillRect(startYard.x, startYard.y, startYard.w, startYard.h);
    ctx.strokeStyle="#fff"; ctx.lineWidth=10;
    ctx.strokeRect(startYard.x, startYard.y, startYard.w, startYard.h);
    drawOfficeSimple(startYard.x + 50, startYard.y + 300);
    startYardCars.forEach(c => drawCar(c.x, c.y, c.color, -Math.PI/2));
    ctx.fillStyle="rgba(255,255,255,0.2)";
    ctx.fillRect(startYardLZone.x, startYardLZone.y, startYardLZone.w, startYardLZone.h);
    ctx.strokeStyle="#ffd700"; ctx.setLineDash([20,10]); ctx.lineWidth=5;
    ctx.strokeRect(startYardLZone.x, startYardLZone.y, startYardLZone.w, startYardLZone.h);
    ctx.setLineDash([]);
    startYardStacks.forEach(s => { if(s.exists) drawLumberLift(s.x, s.y, 30, 60); });
    drawForkliftL1(startForkliftX, startForkliftY, startForkliftAngle, startForkliftCarrying);

    // Draw curved gravel road
    drawCurvedGravelRoad(ctx);
    
    // Draw gravel road editing handles in world space
    if (isEditMode) {
        // Draw guide lines
        ctx.strokeStyle = "rgba(0,255,255,0.3)";
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.moveTo(gravelRoadHandles.center.x, gravelRoadHandles.center.y);
        ctx.lineTo(gravelRoadHandles.top.x, gravelRoadHandles.top.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(gravelRoadHandles.center.x, gravelRoadHandles.center.y);
        ctx.lineTo(gravelRoadHandles.bottom.x, gravelRoadHandles.bottom.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        drawEditHandle(gravelRoadHandles.center.x, gravelRoadHandles.center.y, "MID", "#00ffff", 50);
        drawEditHandle(gravelRoadHandles.top.x, gravelRoadHandles.top.y, "TOP", "#ffff00", 45);
        drawEditHandle(gravelRoadHandles.bottom.x, gravelRoadHandles.bottom.y, "BOT", "#ff00ff", 45);
    }
    
    const mainRoadTopHere = getRoadY(gravelRoadX);
    drawConstructionSign(gravelRoadX + roadWidth/2 + 400, mainRoadTopHere - 500);

    ctx.fillStyle="#333"; ctx.beginPath();
    for(let x=-25000;x<25000;x+=5){let y=getRoadY(x);if(x===-25000)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
    for(let x=25000;x>=-25000;x-=5){ctx.lineTo(x,getRoadY(x)+roadWidth);}
    ctx.fill();
    ctx.strokeStyle="#ffd700"; ctx.lineWidth=6; ctx.setLineDash([40,40]);
    ctx.beginPath();
    for(let x=-25000;x<25000;x+=5){let y=getRoadY(x)+roadWidth/2;if(x===-25000)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
    ctx.stroke(); ctx.setLineDash([]);

    ctx.fillStyle="#333";
    ctx.fillRect(siteLocationX-roadWidth/2, getRoadY(siteLocationX)+roadWidth, roadWidth, lumberRoadLength);

    drawLumberYardGround();
    drawRealisticOffice(remoteLumberYard.x+600, remoteLumberYard.y+remoteLumberYard.h-250, 800, 500);
    const carColors=["#cc0000","#333333","#ffffff","#0000aa","#555555"];
    const carW=67.5, carH=135;
    for(let i=0;i<5;i++){
        ctx.save(); ctx.translate(remoteLumberYard.x+250+(i*135),remoteLumberYard.y+remoteLumberYard.h-600);
        ctx.fillStyle=carColors[i]; ctx.fillRect(-carW/2,-carH/2,carW,carH);
        ctx.fillStyle="#000"; ctx.fillRect(-carW/2-3,-carH/4,5,30); ctx.fillRect(carW/2-2,-carH/4,5,30);
        ctx.fillStyle="rgba(135,206,235,0.7)"; ctx.fillRect(-carW/2+8,-carH/4,carW-16,25);
        ctx.restore();
    }
    ctx.fillStyle="rgba(255,255,255,0.15)"; ctx.fillRect(loadingZone.x,loadingZone.y,loadingZone.w,loadingZone.h);
    lumberStacks.forEach(s=>{if(s.exists)drawLumberLift(s.x,s.y,s.w,s.h);});
    drawForklift(forklift.x,forklift.y,forklift.angle);

    drawTruckDetailed(tractor.x,tractor.y,tractor.angle,true);
    if(activeTrailer) drawTrailerStatic(activeTrailer.x,activeTrailer.y,activeTrailer.angle,activeTrailer.type);

    ctx.restore();
    update();
    requestAnimationFrame(draw);
}

startBtn.onclick=(e)=>{e.preventDefault();if(truckDamage>=100||isRepairing)return;engineOn=!engineOn;timerStarted=true;startBtn.classList.toggle("on");startBtn.innerText=engineOn?"STOP":"START";};
document.getElementById("btnView").onclick=(e)=>{e.preventDefault();currentZoom=(currentZoom===0.35?0.15:0.35);};
const upBtn=document.getElementById("btnUp"),downBtn=document.getElementById("btnDown");
upBtn.addEventListener('pointerdown',(e)=>{e.preventDefault();touch.up=true;});
upBtn.addEventListener('pointerup',(e)=>{e.preventDefault();touch.up=false;});
downBtn.addEventListener('pointerdown',(e)=>{e.preventDefault();touch.down=true;});
downBtn.addEventListener('pointerup',(e)=>{e.preventDefault();touch.down=false;});
function processSteering(e){
    const rect=padEl.getBoundingClientRect();
    let sInput=(e.clientX-(rect.left+rect.width/2))/(rect.width/2);
    sInput=Math.max(-1,Math.min(1,sInput));
    tractor.steerAngle=sInput*0.6; wheelEl.style.transform=`translateX(${sInput*50}px)`;
}
padEl.addEventListener('pointerdown',(e)=>{e.preventDefault();isSteeringActive=true;padEl.setPointerCapture(e.pointerId);processSteering(e);});
padEl.addEventListener('pointermove',(e)=>{if(padEl.hasPointerCapture(e.pointerId))processSteering(e);});
padEl.addEventListener('pointerup',(e)=>{e.preventDefault();isSteeringActive=false;wheelEl.style.transform=`translateX(0px)`;});
window.addEventListener('keydown',(e)=>{if(keys.hasOwnProperty(e.code))keys[e.code]=true;});
window.addEventListener('keyup',(e)=>{if(keys.hasOwnProperty(e.code))keys[e.code]=false;});
draw();
</script>
</body>
</html>