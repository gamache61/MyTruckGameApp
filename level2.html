<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Remi's Semi - Level 2</title>
    <style>
        body { margin: 0; background: #2d613e; font-family: 'Segoe UI', sans-serif; overflow: hidden; color: white; touch-action: none; height: 100vh; width: 100vw; }
        canvas { display: block; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; }
        #gameCanvas { z-index: 1; }
        #model-name { position: absolute; top: 5px; right: 10px; color: rgba(255,255,255,0.3); font-size: 10px; z-index: 20; }
        
        #dashboard { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 10; pointer-events: none; text-align: center; width: 100%; }
        #msg { font-size: 16px; color: #ffd700; text-shadow: 2px 2px #000; font-weight: bold; margin-bottom: 5px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 15px; display: inline-block; width: 94%; line-height: 1.2; box-sizing: border-box; border: 1px solid #444; }
        
        #bottom-stats { display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 5px; pointer-events: auto; }
        .stat-box { background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 5px; border: 1px solid #444; font-family: monospace; font-size: 16px; pointer-events: none; }
        
        #btnBackToStart { width: 35px; height: 35px; border-radius: 50%; background: #ffd700; color: #000; font-weight: bold; font-size: 20px; border: 2px solid #000; display: flex; align-items: center; justify-content: center; pointer-events: auto; cursor: pointer; text-decoration: none; }
        
        #controls { position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: space-between; align-items: flex-end; padding: 0 20px; box-sizing: border-box; z-index: 10; pointer-events: none; }
        .left-controls { display: flex; flex-direction: column; gap: 10px; align-items: flex-start; pointer-events: auto; }
        .pedal-box { display: flex; gap: 8px; }
        
        #steering-pad { width: 140px; height: 140px; background: rgba(0,0,0,0.1); border-radius: 50%; position: absolute; right: 20px; bottom: 76px; margin-right: -20px; touch-action: none; pointer-events: auto; display: flex; align-items: center; justify-content: center; }
        #steering-wheel { width: 130px; height: 130px; border: 15px solid #1a1a1a; border-radius: 50%; box-sizing: border-box; position: relative; transition: transform 0.1s linear; box-shadow: inset 0 0 10px #000, 0 4px 10px rgba(0,0,0,0.5); pointer-events: none; }
        #steering-wheel::before { content: ""; position: absolute; top: 50%; left: -15px; width: 130px; height: 18px; background: #1a1a1a; transform: translateY(-50%); border-radius: 4px; }
        #steering-wheel::after { content: ""; position: absolute; left: 50%; top: 50%; width: 35px; height: 35px; background: #222; border-radius: 50%; transform: translate(-50%, -50%); border: 3px solid #333; box-shadow: 0 2px 5px #000; }

        .btn { width: 70px; height: 60px; background: rgba(51,51,51,0.8); border: 2px solid #555; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 13px; color: white; user-select: none; pointer-events: auto; }
        #btnStart { background: rgba(80,0,0,0.8); border-color: #f00; height: 40px; font-weight: bold; }
        #btnStart.on { background: rgba(0,80,0,0.8); border-color: #0f0; }
        #btnView { height: 40px; font-size: 10px; background: rgba(0, 100, 200, 0.8); }
    </style>
</head>
<body>

<div id="model-name">Model: Gemini 3 Flash</div>

<div id="dashboard">
    <div id="msg">LEVEL 2: CLIMB THE MOUNTAIN TO THE LUMBER KING!</div>
    <div id="bottom-stats">
        <div class="stat-box" style="color: #0f0;">TYPE: FLATBED</div>
        <div class="stat-box" style="color: #ffd700;">CARGO: 12 LIFTS</div>
        <div class="stat-box" style="color: #33ccff;">TIME: <span id="timer">00:00</span></div>
        <div class="stat-box" style="color: #ff9900;">MILES: <span id="miles">0.0</span></div>
        <a href="index.html" id="btnBackToStart">?</a>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<div id="controls">
    <div class="left-controls">
        <div class="pedal-box">
            <div id="btnDown" class="btn">REV</div>
            <div id="btnUp" class="btn">GAS</div>
        </div>
        <div style="display: flex; gap: 8px; margin-top: 5px;">
            <button id="btnStart" class="btn">START</button>
            <button id="btnView" class="btn">VIEW</button>
            <button id="btnDrop" class="btn" style="height:40px; font-size: 10px; background: rgba(200, 100, 0, 0.8);" onclick="handleHitch()">DROP/HOOK</button>
        </div>
    </div>
    <div id="steering-pad"><div id="steering-wheel"></div></div>
</div>

<script>
const roadWidth = 254; 
const remoteLumberYard = { x: 5000, y: 2500, w: 2000, h: 1600 };
const loadingZone = { 
    x: remoteLumberYard.x + (remoteLumberYard.w / 2) - (roadWidth / 2), 
    y: remoteLumberYard.y + (remoteLumberYard.h / 2) - 400, 
    w: roadWidth, 
    h: 800 
};

const roadStartX = loadingZone.x + roadWidth/2;
// UPDATED: More severe, rounded curves using a high-frequency path
const roadPath = [];
const curveIntensity = 1200; // How far left/right the road goes
const curveFrequency = 2000; // How often the road bends
for (let y = 4100; y <= 18000; y += 100) {
    let xOffset = Math.sin(y / curveFrequency) * curveIntensity;
    roadPath.push({x: roadStartX + xOffset, y: y});
}

const lastPoint = roadPath[roadPath.length - 1];
const lumberKingYard = { x: lastPoint.x - 1000, y: lastPoint.y, w: 2000, h: 1600 }; 
const kingLoadingZone = { x: lumberKingYard.x + (lumberKingYard.w / 2) - (roadWidth / 2), y: lumberKingYard.y + 400, w: roadWidth, h: 800 };

let timeElapsed = 0; 
let totalDistance = 0; 
let gameActive = true;
let timerStarted = false;

let breakdownActive = false;
let repairTimer = 0;
let isRepairing = false;
let hasHadBreakdown = false; 

let lumberStacks = [];
for(let i=0; i<10; i++) {
    for(let j=0; j<4; j++) {
        lumberStacks.push({ x: remoteLumberYard.x + 1600 + j*80, y: remoteLumberYard.y + 100 + i*150 });
    }
}

let trees = [];
for(let i=0; i<300; i++) { 
    trees.push({
        x: (Math.random() - 0.5) * 40000 + 5000, 
        y: (Math.random() * 20000) + 2000,
        size: 40 + Math.random() * 30,
        rotation: Math.random() * Math.PI * 2
    }); 
}

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const padEl = document.getElementById("steering-pad");
const wheelEl = document.getElementById("steering-wheel");
const startBtn = document.getElementById("btnStart");
const viewBtn = document.getElementById("btnView");

let engineOn = false;
const touch = { up: false, down: false };
let currentZoom = 0.45;

const tractor = { x: loadingZone.x + loadingZone.w/2, y: loadingZone.y + 500, w: 292.5, h: 67.5, angle: Math.PI/2, speed: 0, accel: 0.05, revAccel: 0.04, friction: 0.98, steerAngle: 0 };
const camera = { x: 0, y: 0 };
let activeTrailer = { x: tractor.x, y: tractor.y - 200, w: 417, h: 72, angle: Math.PI/2, type: 'flatbed' };

const timerInterval = setInterval(() => {
    if (!gameActive || !timerStarted) return;
    timeElapsed++;
    const mins = Math.floor(timeElapsed / 60);
    const secs = timeElapsed % 60;
    document.getElementById("timer").innerText = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    
    if (isRepairing && repairTimer > 0) {
        repairTimer--;
        document.getElementById("msg").innerText = `REPAIRING ENGINE... ${repairTimer}s REMAINING`;
        if (repairTimer <= 0) {
            isRepairing = false;
            breakdownActive = false;
            startBtn.innerText = "START";
            document.getElementById("msg").innerText = "REPAIRS COMPLETE! WATCH THE CURVES!";
        }
    }
}, 1000);

function handleHitch() {}

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

function drawOffice(x, y, title = "OFFICE") {
    ctx.save(); ctx.translate(x, y);
    ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.fillRect(-5, -5, 410, 210);
    ctx.fillStyle = "#546e7a"; ctx.fillRect(0, 0, 400, 200);
    ctx.strokeStyle = "#263238"; ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(0, 100); ctx.lineTo(400, 100); ctx.stroke();
    ctx.fillStyle = "#333"; ctx.fillRect(320, 40, 30, 30);
    ctx.fillStyle = "white"; ctx.font = "bold 20px Arial"; ctx.fillText(title, 20, 40);
    ctx.restore();
}

function drawTree(t) {
    ctx.save(); ctx.translate(t.x, t.y); ctx.rotate(t.rotation);
    ctx.fillStyle = "#1b4d2c"; ctx.beginPath(); ctx.arc(0, 0, t.size, 0, Math.PI*2); ctx.fill();
    ctx.restore();
}

function drawTrailerStatic(x, y, angle) {
    ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
    const tw = 417; const th = 72;
    ctx.fillStyle = "#5d4037"; ctx.fillRect(-tw/2, -th/2, tw, th);
    ctx.fillStyle = "#d2b48c";
    for(let i=0; i<12; i++) {
        let row = i % 6; let side = Math.floor(i/6);
        ctx.fillRect(-tw/2 + 10 + row*65, (side === 0 ? -th/2 + 5 : th/2 - 35), 60, 30);
    }
    ctx.fillStyle = "#111"; ctx.fillRect(-tw/2 + 40, th/2, 55, 8); ctx.fillRect(-tw/2 + 40, -th/2 - 8, 55, 8);
    ctx.restore();
}

function drawTruckDetailed(x, y, angle) {
    ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
    const s = 2.25;
    ctx.fillStyle = "#111"; ctx.fillRect((-130*s)/2, (-30*s)/6, (130*s) - (50*s), (30*s)/3); 
    ctx.fillRect(0, (-30*s)/2, 60*s, 30*s); 
    ctx.fillStyle = breakdownActive ? "#555" : "#800000"; ctx.fillRect(-10*s, (-30*s)/2, 40*s, 30*s); 
    ctx.fillRect(30*s, (-30*s)/2 + 4*s, 30*s, (30*s) - 8*s); 
    ctx.restore();
}

function update() {
    if (!gameActive) return;

    if (totalDistance > 8000 && !hasHadBreakdown) {
        breakdownActive = true;
        hasHadBreakdown = true;
        engineOn = false;
        startBtn.classList.remove("on");
        startBtn.innerText = "FAILED";
        document.getElementById("msg").innerText = "ENGINE FAILURE! PULLING OVER...";
    }

    if (breakdownActive && !isRepairing) {
        tractor.steerAngle = 0.15;
        wheelEl.style.transform = `rotate(45deg)`;
        if (Math.abs(tractor.speed) < 0.1) {
            tractor.speed = 0;
            tractor.steerAngle = 0;
            wheelEl.style.transform = `rotate(0deg)`;
            isRepairing = true;
            repairTimer = 20;
        }
    }

    if (engineOn) {
        if (touch.up) tractor.speed += tractor.accel;
        if (touch.down) tractor.speed -= tractor.revAccel;
    }
    tractor.speed *= tractor.friction;
    if (Math.abs(tractor.speed) > 0.01) {
        totalDistance += Math.abs(tractor.speed);
        document.getElementById("miles").innerText = (totalDistance / 10000).toFixed(1);
    }
    tractor.angle += (tractor.speed / 110) * Math.tan(tractor.steerAngle * 1.5);
    tractor.x += Math.cos(tractor.angle) * tractor.speed;
    tractor.y += Math.sin(tractor.angle) * tractor.speed;
    if (activeTrailer) {
        const pivotX = tractor.x - Math.cos(tractor.angle) * 101.25;
        const pivotY = tractor.y - Math.sin(tractor.angle) * 101.25;
        const dx = pivotX - activeTrailer.x;
        const dy = pivotY - activeTrailer.y;
        activeTrailer.angle = Math.atan2(dy, dx);
        activeTrailer.x = pivotX - Math.cos(activeTrailer.angle) * (activeTrailer.w / 2 - 33.75);
        activeTrailer.y = pivotY - Math.sin(activeTrailer.angle) * (activeTrailer.w / 2 - 33.75);
    }
    camera.x = tractor.x - (canvas.width / currentZoom) / 2;
    camera.y = tractor.y - (canvas.height / currentZoom) / 2;
}

function draw() {
    ctx.clearRect(0,0, canvas.width, canvas.height);
    ctx.save(); ctx.scale(currentZoom, currentZoom); ctx.translate(-camera.x, -camera.y);
    
    ctx.fillStyle = "#2d613e"; ctx.fillRect(-20000, 0, 50000, 25000);
    for(let i=0; i<10; i++) {
        ctx.fillStyle = "rgba(0,0,0,0.05)";
        ctx.fillRect(-20000, 4000 + i*1500, 50000, 800);
    }

    trees.forEach(t => drawTree(t));

    // UPDATED: Severe rounded road curves
    ctx.strokeStyle = "#333"; ctx.lineWidth = roadWidth; ctx.lineCap = "round"; ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.moveTo(roadStartX, remoteLumberYard.y + remoteLumberYard.h);
    roadPath.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.stroke();

    ctx.strokeStyle = "white"; ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(roadPath[0].x - roadWidth/2, roadPath[0].y);
    roadPath.forEach(p => ctx.lineTo(p.x - roadWidth/2, p.y));
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(roadPath[0].x + roadWidth/2, roadPath[0].y);
    roadPath.forEach(p => ctx.lineTo(p.x + roadWidth/2, p.y));
    ctx.stroke();

    ctx.fillStyle = "#5d4037"; ctx.fillRect(remoteLumberYard.x, remoteLumberYard.y, remoteLumberYard.w, remoteLumberYard.h);
    ctx.strokeStyle = "#fff"; ctx.lineWidth = 10; ctx.strokeRect(remoteLumberYard.x, remoteLumberYard.y, remoteLumberYard.w, remoteLumberYard.h);
    drawOffice(remoteLumberYard.x + 50, remoteLumberYard.y + 50);
    ctx.strokeStyle = "#ffd700"; ctx.lineWidth = 15; ctx.strokeRect(loadingZone.x, loadingZone.y, loadingZone.w, loadingZone.h);
    lumberStacks.forEach(s => { ctx.fillStyle = "#d2b48c"; ctx.fillRect(s.x, s.y, 60, 120); });

    ctx.fillStyle = "#5d4037"; ctx.fillRect(lumberKingYard.x, lumberKingYard.y, lumberKingYard.w, lumberKingYard.h);
    ctx.strokeStyle = "#fff"; ctx.lineWidth = 10; ctx.strokeRect(lumberKingYard.x, lumberKingYard.y, lumberKingYard.w, lumberKingYard.h);
    drawOffice(lumberKingYard.x + 50, lumberKingYard.y + 50, "LUMBER KING");

    drawTruckDetailed(tractor.x, tractor.y, tractor.angle);
    if (activeTrailer) drawTrailerStatic(activeTrailer.x, activeTrailer.y, activeTrailer.angle);
    ctx.restore();
    update();
    requestAnimationFrame(draw);
}

startBtn.onclick = () => {
    if(breakdownActive) return;
    engineOn = !engineOn; timerStarted = true;
    startBtn.classList.toggle("on");
    startBtn.innerText = engineOn ? "STOP" : "START";
};
viewBtn.onclick = () => currentZoom = currentZoom === 0.45 ? 0.15 : 0.45;

const upBtn = document.getElementById("btnUp");
const downBtn = document.getElementById("btnDown");
upBtn.addEventListener('mousedown', () => { if(!breakdownActive) touch.up = true; });
upBtn.addEventListener('mouseup', () => { touch.up = false; });
downBtn.addEventListener('mousedown', () => { if(!breakdownActive) touch.down = true; });
downBtn.addEventListener('mouseup', () => { touch.down = false; });

window.addEventListener('keydown', (e) => {
    if (breakdownActive) return;
    if (e.key === 'ArrowUp' || e.key === 'w') touch.up = true;
    if (e.key === 'ArrowDown' || e.key === 's') touch.down = true;
    if (e.key === 'ArrowLeft' || e.key === 'a') { tractor.steerAngle = -0.3; wheelEl.style.transform = `rotate(-90deg)`; }
    if (e.key === 'ArrowRight' || e.key === 'd') { tractor.steerAngle = 0.3; wheelEl.style.transform = `rotate(90deg)`; }
});
window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowUp' || e.key === 'w') touch.up = false;
    if (e.key === 'ArrowDown' || e.key === 's') touch.down = false;
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'ArrowRight' || e.key === 'd') { tractor.steerAngle = 0; wheelEl.style.transform = `rotate(0deg)`; }
});
padEl.addEventListener('touchmove', (e) => {
    if (breakdownActive) return;
    const rect = padEl.getBoundingClientRect();
    let steerInput = (e.touches[0].clientX - (rect.left + rect.width/2)) / (rect.width/2);
    tractor.steerAngle = Math.max(-0.5, Math.min(0.5, steerInput)) * 0.6;
    wheelEl.style.transform = `rotate(${steerInput * 180}deg)`;
});
padEl.addEventListener('touchend', () => { if (!breakdownActive) { tractor.steerAngle = 0; wheelEl.style.transform = `rotate(0deg)`; } });
draw();
</script>
</body>
</html>