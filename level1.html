<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Remi's Semi - Level 1 Ball Lever</title>
    <style>
        body { margin: 0; background: #2d613e; font-family: 'Segoe UI', sans-serif; overflow: hidden; color: white; touch-action: none; height: 100vh; width: 100vw; -webkit-user-select: none; user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; }
        #model-name { position: absolute; top: 5px; right: 10px; color: rgba(255,255,255,0.3); font-size: 10px; z-index: 20; }
        #dashboard { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 10; pointer-events: none; text-align: center; width: 100%; }
        #msg { font-size: 16px; color: #ffd700; text-shadow: 2px 2px #000; font-weight: bold; margin-bottom: 5px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 15px; display: inline-block; width: 94%; line-height: 1.2; box-sizing: border-box; border: 1px solid #444; }
        #bottom-stats { display: flex; justify-content: space-between; align-items: center; padding: 0 3%; margin-top: 5px; pointer-events: auto; }
        .stat-box { background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 5px; border: 1px solid #444; font-family: monospace; font-size: 16px; pointer-events: none; }
        #btnBackToStart { width: 35px; height: 35px; border-radius: 50%; background: #ffd700; color: #000; font-weight: bold; font-size: 20px; border: 2px solid #000; display: flex; align-items: center; justify-content: center; pointer-events: auto; cursor: pointer; text-decoration: none; position: absolute; top: 0; left: 10px; }
        #controls { position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: space-between; align-items: flex-end; padding: 0 20px; box-sizing: border-box; z-index: 10; pointer-events: none; }
        .left-controls { display: flex; flex-direction: column; gap: 10px; align-items: flex-start; pointer-events: auto; }
        .pedal-box { display: flex; gap: 8px; }
        #steering-pad { width: 180px; height: 80px; position: absolute; right: 20px; bottom: 40px; touch-action: none; pointer-events: auto; background: transparent; }
        #steering-wheel { width: 50px; height: 50px; background: rgba(34, 34, 34, 0.8); border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); box-shadow: 0 8px 15px rgba(0,0,0,0.8); pointer-events: none; }
        .btn { width: 70px; height: 60px; background: rgba(51,51,51,0.8); border: 2px solid #555; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 13px; color: white; user-select: none; pointer-events: auto; }
        #btnStart { background: rgba(80,0,0,0.8); border-color: #f00; height: 40px; font-weight: bold; }
        #btnStart.on { background: rgba(0,80,0,0.8); border-color: #0f0; }
        #btnView { height: 40px; font-size: 10px; background: rgba(0, 100, 200, 0.8); }
    </style>
</head>
<body oncontextmenu="return false;">

<div id="model-name">Model: Gemini 3 Flash</div>

<div id="dashboard">
    <div id="msg">MISSION: DROP BOX TRAILER IN MARKED SPOT (YELLOW LINES) IN MAIN YARD & HOOK TO FLATBED</div>
    <div id="bottom-stats">
        <div class="stat-box" style="color: #33ccff;">TIME: <span id="timer">00:00</span></div>
        <div class="stat-box" style="color: #ff9900;">DIST: <span id="miles">0.0</span></div>
        <a href="index.html" id="btnBackToStart">?</a>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<div id="controls">
    <div class="left-controls">
        <div class="pedal-box">
            <div id="btnDown" class="btn">REV</div>
            <div id="btnUp" class="btn">GAS</div>
        </div>
        <div style="display: flex; gap: 8px; margin-top: 5px;">
            <button id="btnStart" class="btn">START</button>
            <button id="btnView" class="btn">VIEW</button>
            <button id="btnDrop" class="btn" style="height:40px; font-size: 10px; background: rgba(200, 100, 0, 0.8);" onclick="handleHitch()">DROP/HOOK</button>
        </div>
    </div>
    <div id="steering-pad"><div id="steering-wheel"></div></div>
</div>

<script>
const roadY = 850;
const scale1km = 3000;
const roadWidth = 254;
const yard = { x: 500, y: roadY - scale1km - 1500, w: 3250, h: 1500 };
const lumberRoadLength = 600;
const remoteLumberYard = { x: 5050 - 1625, y: roadY + roadWidth + lumberRoadLength, w: 3250, h: 1500 };
const loadingZone = { x: remoteLumberYard.x + (remoteLumberYard.w/2) - (roadWidth/2), y: remoteLumberYard.y + (remoteLumberYard.h/2) - 400, w: roadWidth, h: 800 };

const LEFT_AISLE_X  = loadingZone.x - 80;
const RIGHT_AISLE_X = loadingZone.x + loadingZone.w + 80;

const roadCenterX = yard.x + yard.w/2;

/* ============================
   TRIANGLE CORNER CUT ZONES
   - Hypotenuse is out in grass
   - Legs lie along road edges
   ============================ */
const CORNER_TRI_LEG = 150;
let DEBUG_DRAW_CORNER_TRIANGLES = false; // set true to see red filled triangles

function tri(Ax, Ay, Bx, By, Cx, Cy, name) {
    return { A: {x: Ax, y: Ay}, B: {x: Bx, y: By}, C: {x: Cx, y: Cy}, name };
}

const CORNER_TRI_ZONES = [
    // Main Yard NW (left of vertical road, above horizontal road)
    tri(
        roadCenterX - roadWidth/2, roadY,
        (roadCenterX - roadWidth/2) - CORNER_TRI_LEG, roadY,
        roadCenterX - roadWidth/2, roadY - CORNER_TRI_LEG,
        "Main Yard NW"
    ),
    // Main Yard NE (right of vertical road, above horizontal road)
    tri(
        roadCenterX + roadWidth/2, roadY,
        (roadCenterX + roadWidth/2) + CORNER_TRI_LEG, roadY,
        roadCenterX + roadWidth/2, roadY - CORNER_TRI_LEG,
        "Main Yard NE"
    ),
    // Lumber Top NW (left of lumber road, below main road)
    tri(
        5050 - roadWidth/2, roadY + roadWidth,
        (5050 - roadWidth/2) - CORNER_TRI_LEG, roadY + roadWidth,
        5050 - roadWidth/2, (roadY + roadWidth) + CORNER_TRI_LEG,
        "Lumber Top NW"
    ),
    // Lumber Top NE (right of lumber road, below main road)
    tri(
        5050 + roadWidth/2, roadY + roadWidth,
        (5050 + roadWidth/2) + CORNER_TRI_LEG, roadY + roadWidth,
        5050 + roadWidth/2, (roadY + roadWidth) + CORNER_TRI_LEG,
        "Lumber Top NE"
    ),
];

// point-in-triangle (barycentric)
function pointInTriangle(p, a, b, c) {
    const v0x = c.x - a.x, v0y = c.y - a.y;
    const v1x = b.x - a.x, v1y = b.y - a.y;
    const v2x = p.x - a.x, v2y = p.y - a.y;

    const dot00 = v0x*v0x + v0y*v0y;
    const dot01 = v0x*v1x + v0y*v1y;
    const dot02 = v0x*v2x + v0y*v2y;
    const dot11 = v1x*v1x + v1y*v1y;
    const dot12 = v1x*v2x + v1y*v2y;

    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) return false;

    const inv = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * inv;
    const v = (dot00 * dot12 - dot01 * dot02) * inv;

    return (u >= 0) && (v >= 0) && (u + v <= 1);
}

function whichTriangleZone(x, y) {
    const p = { x, y };
    for (const z of CORNER_TRI_ZONES) {
        if (pointInTriangle(p, z.A, z.B, z.C)) return z.name;
    }
    return null;
}

function drawCornerTrianglesDebug() {
    if (!DEBUG_DRAW_CORNER_TRIANGLES) return;

    for (const z of CORNER_TRI_ZONES) {
        // fill triangle
        ctx.fillStyle = "rgba(255,0,0,0.35)";
        ctx.beginPath();
        ctx.moveTo(z.A.x, z.A.y);
        ctx.lineTo(z.B.x, z.B.y);
        ctx.lineTo(z.C.x, z.C.y);
        ctx.closePath();
        ctx.fill();

        // hypotenuse (longest side BC) in thick red
        ctx.strokeStyle = "rgba(255,0,0,0.95)";
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(z.B.x, z.B.y);
        ctx.lineTo(z.C.x, z.C.y);
        ctx.stroke();
    }
}

/* ============================ */

const parkingSpots = [
    { x: yard.x + 1600, y: yard.y + 250, w: 450, h: 100, occupied: false },
    { x: yard.x + 1900, y: yard.y + 250, w: 450, h: 100, occupied: true },
    { x: yard.x + 2200, y: yard.y + 250, w: 450, h: 100, occupied: true },
    { x: yard.x + 2500, y: yard.y + 250, w: 450, h: 100, occupied: true },
    { x: yard.x + 2800, y: yard.y + 250, w: 450, h: 100, occupied: false }
];

let timeElapsed = 0, totalDistance = 0, gameActive = true, missionStep = 1, timerStarted = false;
let forkliftX = loadingZone.x - 200, forkliftY = loadingZone.y + 400, forkliftAngle = 0, liftsLoaded = 0, forkliftState = "idle";
let forkliftTargetX = 0, forkliftTargetY = 0;
let forkliftPath = [];
let forkliftPathIndex = 0;
let currentPickupPile = 'left';
let isOffRoad = false;

function moveAlongPath(speed) {
    if (forkliftPathIndex >= forkliftPath.length) return true;
    let wp = forkliftPath[forkliftPathIndex];
    let dx = wp.x - forkliftX, dy = wp.y - forkliftY;
    let dist = Math.sqrt(dx * dx + dy * dy);
    forkliftAngle = Math.atan2(dy, dx);
    if (dist > speed) {
        forkliftX += Math.cos(forkliftAngle) * speed;
        forkliftY += Math.sin(forkliftAngle) * speed;
        return false;
    } else {
        forkliftX = wp.x;
        forkliftY = wp.y;
        forkliftPathIndex++;
        return forkliftPathIndex >= forkliftPath.length;
    }
}

let lumberStacks = [];
for (let i = 0; i < 12; i++) {
    for (let j = 0; j < 2; j++) {
        lumberStacks.push({ x: loadingZone.x - 210 - (j+1)*100, y: loadingZone.y - 220 + i*70, exists: true, pile: 'left' });
        lumberStacks.push({ x: loadingZone.x + loadingZone.w + 110 + (j+1)*100, y: loadingZone.y - 220 + i*70, exists: true, pile: 'right' });
    }
}

let trees = [];
for (let i = 0; i < 100; i++) trees.push({ x: (Math.random() - 0.5) * 20000 + 5000, y: (Math.random() - 0.5) * 15000 + 1000, size: 40 + Math.random() * 30, rotation: Math.random() * Math.PI * 2 });
let houses = [];
for (let i = 0; i < 25; i++) houses.push({ x: (Math.random() - 0.5) * 18000 + 5000, y: (Math.random() - 0.5) * 12000 + 1000, color: ['#a52a2a', '#4682b4', '#2e8b57', '#8b4513', '#708090'][Math.floor(Math.random()*5)], rot: (Math.random() > 0.5 ? 0 : Math.PI/2) });
let staffCars = [];
for (let i = 0; i < 6; i++) staffCars.push({ x: remoteLumberYard.x + 100 + (i * 80), y: remoteLumberYard.y + 150, color: ['#c0c0c0', '#444', '#fff', '#003366', '#800000'][i % 5] });
let signs = JSON.parse(localStorage.getItem('remiSigns')) || [{ x: 2375, y: 1304, w: 240, h: 120, text: "TO MAIN YARD" }, { x: 5050, y: 1304, w: 240, h: 120, text: "TO LUMBER YARD" }];

const canvas = document.getElementById("gameCanvas"), ctx = canvas.getContext("2d");
const padEl = document.getElementById("steering-pad"), ballEl = document.getElementById("steering-wheel"), startBtn = document.getElementById("btnStart"), viewBtn = document.getElementById("btnView");
let engineOn = false;
const touch = { up: false, down: false };
let currentZoom = 0.35;

const tractor = { x: 0, y: 1055, w: 292.5, h: 67.5, angle: 0, speed: 0, accel: 0.05, revAccel: 0.04, friction: 0.98, steerAngle: 0 };
const camera = { x: 0, y: 0 };

let allTrailers = [
    { x: -280, y: 1055, w: 417, h: 72, angle: 0, type: 'box', original: true },
    { x: yard.x + 1900, y: yard.y + 250, w: 432, h: 72, angle: Math.PI/2, type: 'flatbed' },
    { x: yard.x + 2200, y: yard.y + 250, w: 417, h: 72, angle: Math.PI/2, type: 'box' },
    { x: yard.x + 2500, y: yard.y + 250, w: 432, h: 72, angle: Math.PI/2, type: 'flatbed' }
];
let activeTrailer = allTrailers[0];

const timerInterval = setInterval(() => {
    if (!gameActive || !timerStarted) return;
    timeElapsed++;
    const mins = Math.floor(timeElapsed / 60);
    const secs = timeElapsed % 60;
    document.getElementById("timer").innerText = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}, 1000);

function isTrailerInParkingSpot(trailer) {
    for (let spot of parkingSpots) {
        let dx = Math.abs(trailer.x - spot.x);
        let dy = Math.abs(trailer.y - spot.y);
        if (dx < 50 && dy < 50) return true;
    }
    return false;
}

function isPointOnRoad(x, y) {
    const mainRoadLeft = -15000;
    const mainRoadRight = 30000;
    const mainRoadTop = roadY;
    const mainRoadBottom = roadY + roadWidth;
    
    const vertRoadLeft = roadCenterX - roadWidth/2;
    const vertRoadRight = roadCenterX + roadWidth/2;
    const vertRoadTop = yard.y + yard.h;
    const vertRoadBottom = roadY;
    
    const lumberRoadLeft = 5050 - roadWidth/2;
    const lumberRoadRight = 5050 + roadWidth/2;
    const lumberRoadTop = roadY + roadWidth;
    const lumberRoadBottom = roadY + roadWidth + lumberRoadLength;
    
    const inYard = x > yard.x && x < yard.x + yard.w && y > yard.y && y < yard.y + yard.h;
    const inLumberYard = x > remoteLumberYard.x && x < remoteLumberYard.x + remoteLumberYard.w && y > remoteLumberYard.y && y < remoteLumberYard.y + remoteLumberYard.h;
    
    const onMainRoad = x > mainRoadLeft && x < mainRoadRight && y > mainRoadTop && y < mainRoadBottom;
    const onVertRoad = x > vertRoadLeft && x < vertRoadRight && y > vertRoadTop && y < vertRoadBottom;
    const onLumberRoad = x > lumberRoadLeft && x < lumberRoadRight && y > lumberRoadTop && y < lumberRoadBottom;
    
    return onMainRoad || onVertRoad || onLumberRoad || inYard || inLumberYard;
}

function checkTrailerOffRoadAtCorner() {
    if (!activeTrailer) return false;
    
    let halfW = activeTrailer.w / 2;
    let halfH = activeTrailer.h / 2;
    
    let trailerCenter = { x: activeTrailer.x, y: activeTrailer.y };
    
    let corner1 = {
        x: activeTrailer.x + Math.cos(activeTrailer.angle) * halfW - Math.sin(activeTrailer.angle) * halfH,
        y: activeTrailer.y + Math.sin(activeTrailer.angle) * halfW + Math.cos(activeTrailer.angle) * halfH
    };
    let corner2 = {
        x: activeTrailer.x + Math.cos(activeTrailer.angle) * halfW + Math.sin(activeTrailer.angle) * halfH,
        y: activeTrailer.y + Math.sin(activeTrailer.angle) * halfW - Math.cos(activeTrailer.angle) * halfH
    };
    let corner3 = {
        x: activeTrailer.x - Math.cos(activeTrailer.angle) * halfW - Math.sin(activeTrailer.angle) * halfH,
        y: activeTrailer.y - Math.sin(activeTrailer.angle) * halfW + Math.cos(activeTrailer.angle) * halfH
    };
    let corner4 = {
        x: activeTrailer.x - Math.cos(activeTrailer.angle) * halfW + Math.sin(activeTrailer.angle) * halfH,
        y: activeTrailer.y - Math.sin(activeTrailer.angle) * halfW - Math.cos(activeTrailer.angle) * halfH
    };
    
    // Only enforce in triangle zones
    let inZoneName = whichTriangleZone(trailerCenter.x, trailerCenter.y) ||
                     whichTriangleZone(corner1.x, corner1.y) ||
                     whichTriangleZone(corner2.x, corner2.y) ||
                     whichTriangleZone(corner3.x, corner3.y) ||
                     whichTriangleZone(corner4.x, corner4.y);
    
    if (!inZoneName) return false;
    
    // Check if any part is off-road
    let centerOffRoad = !isPointOnRoad(trailerCenter.x, trailerCenter.y);
    let corner1OffRoad = !isPointOnRoad(corner1.x, corner1.y);
    let corner2OffRoad = !isPointOnRoad(corner2.x, corner2.y);
    let corner3OffRoad = !isPointOnRoad(corner3.x, corner3.y);
    let corner4OffRoad = !isPointOnRoad(corner4.x, corner4.y);
    
    return centerOffRoad || corner1OffRoad || corner2OffRoad || corner3OffRoad || corner4OffRoad;
}

function handleHitch() {
    if (activeTrailer) {
        const inYard = activeTrailer.x > yard.x - 100 && activeTrailer.x < yard.x + yard.w + 100 && activeTrailer.y > yard.y - 100 && activeTrailer.y < yard.y + yard.h + 100;
        
        if (missionStep === 1 && activeTrailer.type === 'box') {
            if (!isTrailerInParkingSpot(activeTrailer)) {
                document.getElementById("msg").innerText = "TRAILER MUST BE IN MARKED PARKING SPOT (YELLOW LINES) TO UNHOOK!";
                return;
            }
            if (inYard) {
                missionStep = 2;
                document.getElementById("msg").innerText = "STEP 2: NOW HOOK TO THE FLATBED IN THE YARD!";
                activeTrailer = null;
            }
        } else {
            activeTrailer = null;
        }
    } else {
        allTrailers.forEach(t => {
            const dx = tractor.x - t.x;
            const dy = tractor.y - t.y;
            if (Math.sqrt(dx*dx + dy*dy) < 300) {
                activeTrailer = t;
                if (missionStep === 2 && t.type === 'flatbed') {
                    missionStep = 3;
                    document.getElementById("msg").innerText = "STEP 3: DRIVE TO THE LOADING ZONE AT THE LUMBER YARD!";
                }
            }
        });
    }
}

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

function drawLumberLift(x, y, w, h) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = "#e3c5a8";
    ctx.fillRect(0, 0, w, h);
    ctx.strokeStyle = "#8b4513";
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, w, h);
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, 0, w, h);
    ctx.clip();
    for (let i = 0; i < w; i += 4) {
        ctx.fillStyle = "rgba(0,0,0,0.05)";
        ctx.fillRect(i + 3, 0, 1, h);
    }
    ctx.restore();
    ctx.fillStyle = "#111";
    ctx.fillRect(0, h * 0.2, w, 3);
    ctx.fillRect(0, h * 0.8, w, 3);
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    ctx.fillRect(5, h, w, 8);
    ctx.restore();
}

function drawHouse(h) {
    ctx.save();
    ctx.translate(h.x, h.y);
    ctx.rotate(h.rot);
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    ctx.fillRect(-105, -85, 210, 170);
    ctx.fillStyle = h.color;
    ctx.fillRect(-100, -80, 200, 160);
    ctx.fillStyle = "#3e2723";
    ctx.beginPath();
    ctx.moveTo(-110, -90);
    ctx.lineTo(110, -90);
    ctx.lineTo(0, 0);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#4e342e";
    ctx.beginPath();
    ctx.moveTo(-110, 90);
    ctx.lineTo(110, 90);
    ctx.lineTo(0, 0);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#212121";
    ctx.fillRect(50, -60, 20, 20);
    ctx.restore();
}

function drawOffice(x, y) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.fillRect(-5, -5, 410, 210);
    ctx.fillStyle = "#546e7a";
    ctx.fillRect(0, 0, 400, 200);
    ctx.strokeStyle = "#263238";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(0, 100);
    ctx.lineTo(400, 100);
    ctx.stroke();
    ctx.fillStyle = "rgba(0,0,0,0.1)";
    ctx.fillRect(0, 100, 400, 100);
    ctx.fillStyle = "#333";
    ctx.fillRect(320, 40, 30, 30);
    ctx.restore();
}

function drawTree(t) {
    ctx.save();
    ctx.translate(t.x, t.y);
    ctx.rotate(t.rotation);
    ctx.fillStyle = "#1b4d2c";
    ctx.beginPath();
    ctx.arc(0, 0, t.size, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "#2d613e";
    ctx.beginPath();
    ctx.arc(-t.size/4, -t.size/4, t.size/1.5, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "#388e3c";
    ctx.beginPath();
    ctx.arc(t.size/5, t.size/5, t.size/2, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
}

function drawCar(x, y, color, angle = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    ctx.fillRect(-32, -19, 64, 38);
    ctx.fillStyle = color;
    ctx.fillRect(-30, -17.5, 60, 35);
    ctx.fillStyle = "#333";
    ctx.fillRect(5, -14, 15, 28);
    ctx.fillStyle = "#fff";
    ctx.fillRect(26, -15, 4, 8);
    ctx.fillRect(26, 7, 4, 8);
    ctx.fillStyle = "#111";
    ctx.fillRect(-20, -19.5, 12, 4);
    ctx.fillRect(10, -19.5, 12, 4);
    ctx.fillRect(-20, 15.5, 12, 4);
    ctx.fillRect(10, 15.5, 12, 4);
    ctx.restore();
}

function drawForklift(x, y, angle) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.fillStyle = "#e67e22";
    ctx.fillRect(-30, -20, 60, 40);
    ctx.fillStyle = "#333";
    ctx.fillRect(-35, -20, 15, 40);
    ctx.fillStyle = "#222";
    ctx.fillRect(30, -18, 5, 36);
    ctx.fillStyle = "#777";
    ctx.fillRect(35, -15, 45, 4);
    ctx.fillRect(35, 11, 45, 4);
    ctx.fillStyle = "#000";
    ctx.fillRect(10, -23, 15, 6);
    ctx.fillRect(10, 17, 15, 6);
    ctx.fillRect(-25, -23, 12, 6);
    ctx.fillRect(-25, 17, 12, 6);
    if (forkliftState === "to_truck") {
        drawLumberLift(35, -15, 40, 30);
    }
    ctx.restore();
}

function drawTrailerStatic(x, y, angle, type) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    if (type === 'box') {
        const tw = 417, th = 72;
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.fillRect(-tw/2 + 5, -th/2 + 5, tw, th);
        ctx.fillStyle = "#eeeeee";
        ctx.fillRect(-tw/2, -th/2, tw, th);
        ctx.strokeStyle = "#cccccc";
        ctx.lineWidth = 2;
        for (let i = -tw/2 + 40; i < tw/2 - 10; i += 12) {
            ctx.beginPath();
            ctx.moveTo(i, -th/2 + 2);
            ctx.lineTo(i, th/2 - 2);
            ctx.stroke();
        }
        ctx.fillStyle = "#dddddd";
        ctx.fillRect(tw/2 - 15, -th/2, 15, th);
        ctx.fillStyle = "#bbbbbb";
        ctx.fillRect(-tw/2, -th/2, 8, th);
        ctx.fillStyle = "#333";
        ctx.fillRect(-tw/2 + 2, -th/4, 4, 2);
        ctx.fillRect(-tw/2 + 2, th/4, 4, 2);
        ctx.fillStyle = "#111";
        ctx.fillRect(-tw/2 + 40, th/2, 55, 8);
        ctx.fillRect(-tw/2 + 40, -th/2 - 8, 55, 8);
    } else {
        const th = 72, tw = 432;
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.fillRect(-tw/2 + 5, -th/2 + 5, tw, th);
        for (let i = -th/2; i < th/2; i += 6) {
            ctx.fillStyle = (Math.floor(i/6) % 2 === 0) ? "#5d4037" : "#4a352f";
            ctx.fillRect(-tw/2, i, tw, 6);
        }
        ctx.fillStyle = "#b0b0b0";
        ctx.fillRect(-tw/2, -th/2, tw, 5);
        ctx.fillRect(-tw/2, th/2 - 5, tw, 5);
        for (let i = -tw/2; i < tw/2; i += 20) {
            ctx.fillStyle = (Math.floor(i/20) % 2 === 0) ? "#d32f2f" : "#ffffff";
            ctx.fillRect(i, -th/2 + 1, 10, 2);
            ctx.fillRect(i, th/2 - 3, 10, 2);
        }
        ctx.fillStyle = "#111";
        ctx.strokeStyle = "#ffd700";
        ctx.lineWidth = 2.5;
        for (let i = -tw/2 + 45; i < tw/2 - 45; i += 55) {
            ctx.fillRect(i, th/2 - 6, 8, 6);
            ctx.beginPath();
            ctx.moveTo(i + 4, th/2 - 4);
            ctx.lineTo(i + 4, -th/2 + 4);
            ctx.stroke();
        }
        if (missionStep >= 3) {
            for (let i = 0; i < liftsLoaded; i++) {
                let side = (i < 3) ? 0 : (i < 9 ? 1 : 0);
                let row  = (i < 3) ? i : (i < 9 ? i - 3 : i - 6);
                let lx = -tw/2 + 10 + row * 65;
                let ly = (side === 0 ? -th/2 + 5 : th/2 - 35);
                let lw = 60, lh = 30;
                drawLumberLift(lx, ly, lw, lh);
            }
        }
        ctx.fillStyle = "#333";
        ctx.fillRect(tw/2 - 6, -th/2, 6, th);
        ctx.fillStyle = "#000";
        ctx.fillRect(-tw/2 + 35, -th/2 - 7, 45, 7);
        ctx.fillRect(-tw/2 + 35, th/2, 45, 7);
    }
    ctx.restore();
}

function drawTruckDetailed(x, y, angle, isSteering = false, cabColor = "#800000") {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    
    const s = 2.25;
    
    ctx.fillStyle = "#111";
    ctx.fillRect((-130*s)/2, (-30*s)/6, (130*s) - (50*s), (30*s)/3);
    ctx.fillRect(0, (-30*s)/2, 60*s, 30*s);
    
    ctx.fillStyle = "#000";
    ctx.fillRect(-62*s, -12*s, 12*s, 6*s);
    ctx.fillRect(-62*s, 6*s, 12*s, 6*s);
    ctx.fillRect(-45*s, -12*s, 12*s, 6*s);
    ctx.fillRect(-45*s, 6*s, 12*s, 6*s);

    ctx.save();
    ctx.translate(46*s, (-30*s)/2);
    if (isSteering) ctx.rotate(tractor.steerAngle);
    ctx.fillRect(-6*s, -2.5*s, 12*s, 5*s);
    ctx.restore();
    
    ctx.save();
    ctx.translate(46*s, (30*s)/2);
    if (isSteering) ctx.rotate(tractor.steerAngle);
    ctx.fillRect(-6*s, -2.5*s, 12*s, 5*s);
    ctx.restore();

    ctx.fillStyle = cabColor;
    ctx.fillRect(-10*s, (-30*s)/2, 40*s, 30*s);
    ctx.fillRect(30*s, (-30*s)/2 + 4*s, 30*s, (30*s) - 8*s);

    ctx.fillStyle = "#FFD700";
    for(let i = 0; i < 4; i++) {
        let ly = (-30*s)/2 + 4*s + (i * 6.5 * s);
        ctx.fillRect(27*s, ly, 3*s, 3*s);
    }

    ctx.fillStyle = "#777";
    ctx.fillRect(-12*s, (-30*s)/2 - 5*s, 6*s, 6*s);
    ctx.fillRect(-12*s, (30*s)/2 - 1*s, 6*s, 6*s);
    
    ctx.fillStyle = "#aaa";
    ctx.fillRect(30*s, (-30*s)/2 - 4*s, 4*s, 5*s);
    ctx.fillRect(30*s, (30*s)/2 - 1*s, 4*s, 5*s);

    const bumperGrd = ctx.createLinearGradient(58 * s, 0, 65 * s, 0);
    bumperGrd.addColorStop(0, "#888");
    bumperGrd.addColorStop(0.5, "#eee");
    bumperGrd.addColorStop(1, "#999");
    ctx.fillStyle = bumperGrd;
    ctx.fillRect(58 * s, (-30 * s) / 2 - 1, 5 * s, 30 * s + 2);
    
    ctx.restore();
}

function drawSign(sign) {
    ctx.save();
    const {x, y, w, h, text} = sign;
    ctx.fillStyle = "#555";
    ctx.fillRect(x - 10, y, 20, 160);
    ctx.fillStyle = "white";
    ctx.fillRect(x - w/2, y - h, w, h);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 4;
    ctx.strokeRect(x - w/2, y - h, w, h);
    ctx.fillStyle = "black";
    ctx.font = `bold ${h/4}px Arial`;
    ctx.textAlign = "center";
    ctx.fillText(text, x, y - h/2 + 10);
    ctx.restore();
}

function drawParkingSpot(spot) {
    ctx.save();
    ctx.translate(spot.x, spot.y);
    ctx.rotate(Math.PI/2);
    
    ctx.strokeStyle = "#ffd700";
    ctx.lineWidth = 4;
    ctx.setLineDash([20, 15]);
    ctx.strokeRect(-spot.w/2, -spot.h/2, spot.w, spot.h);
    ctx.setLineDash([]);
    
    ctx.restore();
}

function endLevel1() {
    gameActive = false;
    let finalTime = document.getElementById("timer").innerText;
    let finalMiles = (totalDistance / 10000).toFixed(1);
    setTimeout(() => {
        let name = prompt(`LEVEL 1 COMPLETE!\nTime: ${finalTime} | Miles: ${finalMiles}\nEnter your name:`, "Remi");
        if (!name) name = "Driver";
        localStorage.setItem('remi_l1_time', finalTime);
        localStorage.setItem('remi_l1_miles', finalMiles);
        document.getElementById("msg").innerHTML = `MISSION COMPLETE! PREPARING LEVEL 2...`;
        setTimeout(() => { window.location.assign("level2.html"); }, 2000);
    }, 500);
}

function update() {
    if (!gameActive) return;
    if (engineOn) {
        if (touch.up) tractor.speed += tractor.accel;
        if (touch.down) tractor.speed -= tractor.revAccel;
    }
    tractor.speed *= tractor.friction;
    
    // Check if trailer is off-road at a corner
    isOffRoad = checkTrailerOffRoadAtCorner();
    
    if (isOffRoad) {
        document.getElementById("msg").innerText = "⚠️ TRAILER OFF ROAD! BACK UP TO ADJUST!";
        
        if (tractor.speed > 0) {
            tractor.speed = 0;
        }
    } else {
        if (document.getElementById("msg").innerText.includes("OFF ROAD")) {
            if (missionStep === 1) {
                document.getElementById("msg").innerText = "MISSION: DROP BOX TRAILER IN MARKED SPOT (YELLOW LINES) IN MAIN YARD & HOOK TO FLATBED";
            } else if (missionStep === 2) {
                document.getElementById("msg").innerText = "STEP 2: NOW HOOK TO THE FLATBED IN THE YARD!";
            } else if (missionStep === 3) {
                document.getElementById("msg").innerText = "STEP 3: DRIVE TO THE LOADING ZONE AT THE LUMBER YARD!";
            }
        }
    }
    
    let destX = (missionStep < 3) ? (yard.x + yard.w/2) : (loadingZone.x + loadingZone.w/2);
    let destY = (missionStep < 3) ? (yard.y + yard.h/2) : (loadingZone.y + loadingZone.h/2);
    let distToDest = Math.sqrt(Math.pow(destX - tractor.x, 2) + Math.pow(destY - tractor.y, 2));
    document.getElementById("miles").innerText = (distToDest / 10000).toFixed(1);
    if (Math.abs(tractor.speed) > 0.01) totalDistance += Math.abs(tractor.speed);
    else tractor.speed = 0;
    if (tractor.steerAngle === 0 && Math.abs(tractor.speed) > 0.1) {
        let cur = ((tractor.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
        if (cur < 0.3 || cur > (Math.PI * 2 - 0.3)) tractor.angle += (Math.round(tractor.angle / (Math.PI * 2)) * (Math.PI * 2) - tractor.angle) * 0.1;
    }
    tractor.angle += (tractor.speed / 150) * Math.tan(tractor.steerAngle * 1.5);
    tractor.x += Math.cos(tractor.angle) * tractor.speed;
    tractor.y += Math.sin(tractor.angle) * tractor.speed;
    if (activeTrailer) {
        const pX = tractor.x - Math.cos(tractor.angle) * 110;
        const pY = tractor.y - Math.sin(tractor.angle) * 110;
        const dx = pX - activeTrailer.x;
        const dy = pY - activeTrailer.y;
        activeTrailer.angle = Math.atan2(dy, dx);
        activeTrailer.x = pX - Math.cos(activeTrailer.angle) * (activeTrailer.w / 2 - 33.75);
        activeTrailer.y = pY - Math.sin(activeTrailer.angle) * (activeTrailer.w / 2 - 33.75);
    }

    if (missionStep === 3 && activeTrailer && activeTrailer.type === 'flatbed' && Math.abs(tractor.speed) < 0.1 &&
        activeTrailer.x > loadingZone.x && activeTrailer.x < loadingZone.x + loadingZone.w &&
        activeTrailer.y > loadingZone.y && activeTrailer.y < loadingZone.y + loadingZone.h) {
        let isFarSide = (liftsLoaded >= 3 && liftsLoaded < 9);
        let row = (liftsLoaded < 3) ? liftsLoaded : (liftsLoaded < 9 ? liftsLoaded - 3 : liftsLoaded - 6);
        let offS = (isFarSide ? 60 : -60);
        let offR = -180 + (row * 65);
        let targetX = activeTrailer.x + offR * Math.cos(activeTrailer.angle) - offS * Math.sin(activeTrailer.angle);
        let targetY = activeTrailer.y + offR * Math.sin(activeTrailer.angle) + offS * Math.cos(activeTrailer.angle);
        if (liftsLoaded < 12) {
            if (forkliftState === "idle") forkliftState = "to_pickup";
            if (forkliftState === "to_pickup") {
                let pile = isFarSide ? 'right' : 'left';
                let s = lumberStacks.find(s => s.exists && s.pile === pile) || lumberStacks.find(s => s.exists);
                if (s) {
                    let aisleX = (s.pile === 'left') ? LEFT_AISLE_X : RIGHT_AISLE_X;
                    let stackTX = s.x + 15, stackTY = s.y + 30;
                    if (forkliftPath.length === 0) {
                        forkliftPath = [{ x: aisleX,  y: forkliftY }, { x: aisleX,  y: stackTY }, { x: stackTX, y: stackTY }];
                        forkliftPathIndex = 0;
                    }
                    let done = moveAlongPath(8);
                    if (done) {
                        s.exists = false;
                        forkliftPath = [];
                        forkliftTargetX = targetX;
                        forkliftTargetY = targetY;
                        currentPickupPile = s.pile;
                        forkliftState = "to_truck";
                    }
                }
            } else if (forkliftState === "to_truck") {
                if (forkliftPath.length === 0) {
                    let pickupAisleX = (currentPickupPile === 'left') ? LEFT_AISLE_X : RIGHT_AISLE_X;
                    let targetAisleX = (forkliftTargetX < loadingZone.x + loadingZone.w / 2) ? LEFT_AISLE_X : RIGHT_AISLE_X;
                    let safeY = activeTrailer.y + 350;
                    if (pickupAisleX === targetAisleX) {
                        forkliftPath = [{ x: pickupAisleX, y: forkliftY }, { x: pickupAisleX, y: forkliftTargetY }, { x: forkliftTargetX, y: forkliftTargetY }];
                    } else {
                        forkliftPath = [{ x: pickupAisleX, y: forkliftY }, { x: pickupAisleX, y: safeY }, { x: targetAisleX, y: safeY }, { x: targetAisleX, y: forkliftTargetY }, { x: forkliftTargetX, y: forkliftTargetY }];
                    }
                    forkliftPathIndex = 0;
                }
                let done = moveAlongPath(10);
                if (done) {
                    forkliftPath = [];
                    liftsLoaded++;
                    forkliftState = "to_pickup";
                }
            }
        } else endLevel1();
    }
    camera.x = tractor.x;
    camera.y = tractor.y;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let destX = (missionStep < 3) ? (yard.x + yard.w/2) : (loadingZone.x + loadingZone.w/2);
    let destY = (missionStep < 3) ? (yard.y + yard.h/2) : (loadingZone.y + loadingZone.h/2);
    let angleToDest = Math.atan2(destY - tractor.y, destX - tractor.x);
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.rotate(-tractor.angle - Math.PI/2);
    ctx.scale(currentZoom, currentZoom);
    ctx.translate(-camera.x, -camera.y);
    ctx.fillStyle = "#2d613e";
    ctx.fillRect(-15000, -20000, 40000, 40000);
    houses.forEach(h => drawHouse(h));
    trees.forEach(t => drawTree(t));
    ctx.fillStyle = "#333";
    ctx.fillRect(-15000, roadY, 30000, roadWidth);
    ctx.fillRect(roadCenterX - roadWidth/2, yard.y + yard.h, roadWidth, scale1km);
    ctx.fillRect(5050 - roadWidth/2, roadY + roadWidth, roadWidth, lumberRoadLength);
    
    // DEBUG: draw triangle zones (set DEBUG_DRAW_CORNER_TRIANGLES = true to see them)
    drawCornerTrianglesDebug();
    
    ctx.strokeStyle = "#ffd700";
    ctx.lineWidth = 6;
    ctx.setLineDash([40, 40]);
    ctx.beginPath();
    ctx.moveTo(-15000, roadY + roadWidth/2);
    ctx.lineTo(30000, roadY + roadWidth/2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(roadCenterX, yard.y + yard.h);
    ctx.lineTo(roadCenterX, roadY);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = "#555";
    ctx.fillRect(yard.x, yard.y, yard.w, yard.h);
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 10;
    ctx.strokeRect(yard.x, yard.y, yard.w, yard.h);
    
    parkingSpots.forEach(spot => drawParkingSpot(spot));
    
    ctx.fillStyle = "#444";
    ctx.fillRect(yard.x + 50, yard.y + 50, 1000, 600);
    drawTruckDetailed(yard.x + 250, yard.y + 350, Math.PI/2, false, "#0000FF");
    drawTrailerStatic(yard.x + 750, yard.y + 300, Math.PI/2, 'box');
    ctx.fillStyle = "#555";
    ctx.fillRect(remoteLumberYard.x, remoteLumberYard.y, remoteLumberYard.w, remoteLumberYard.h);
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 10;
    ctx.strokeRect(remoteLumberYard.x, remoteLumberYard.y, remoteLumberYard.w, remoteLumberYard.h);
    drawOffice(remoteLumberYard.x + 50, remoteLumberYard.y + 300);
    staffCars.forEach(c => drawCar(c.x, c.y, c.color, -Math.PI/2));
    ctx.fillStyle = "rgba(255,255,255,0.2)";
    ctx.fillRect(loadingZone.x, loadingZone.y, loadingZone.w, loadingZone.h);
    ctx.strokeStyle = "#ffd700";
    ctx.setLineDash([20, 10]);
    ctx.lineWidth = 5;
    ctx.strokeRect(loadingZone.x, loadingZone.y, loadingZone.w, loadingZone.h);
    ctx.setLineDash([]);
    lumberStacks.forEach(s => { if (s.exists) drawLumberLift(s.x, s.y, 30, 60); });
    drawForklift(forkliftX, forkliftY, forkliftAngle);
    signs.forEach(s => drawSign(s));
    drawTruckDetailed(tractor.x, tractor.y, tractor.angle, true);
    allTrailers.forEach(t => { if (t !== activeTrailer) drawTrailerStatic(t.x, t.y, t.angle, t.type); });
    if (activeTrailer) drawTrailerStatic(activeTrailer.x, activeTrailer.y, activeTrailer.angle, activeTrailer.type);
    ctx.restore();

    ctx.save();
    ctx.translate(canvas.width / 2, 140);
    ctx.fillStyle = "black";
    ctx.fillRect(-45, -15, 90, 30);
    ctx.strokeStyle = "#ffd700";
    ctx.lineWidth = 1.5;
    ctx.strokeRect(-45, -15, 90, 30);
    let relativeAngle = ((angleToDest - tractor.angle + Math.PI) % (Math.PI * 2)) - Math.PI;
    let dirText = "STRAIGHT";
    if (relativeAngle < -0.2) dirText = "LEFT";
    else if (relativeAngle > 0.2) dirText = "RIGHT";
    ctx.fillStyle = "#ffd700";
    ctx.font = "bold 14px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(dirText, 0, 0);
    ctx.restore();

    update();
    requestAnimationFrame(draw);
}

startBtn.onclick = (e) => {
    e.preventDefault();
    engineOn = !engineOn;
    timerStarted = true;
    startBtn.classList.toggle("on");
    startBtn.innerText = engineOn ? "STOP" : "START";
};
viewBtn.onclick = (e) => {
    e.preventDefault();
    currentZoom = (currentZoom === 0.35 ? 0.15 : 0.35);
};
const upBtn = document.getElementById("btnUp"), downBtn = document.getElementById("btnDown");
upBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); touch.up = true; upBtn.setPointerCapture(e.pointerId); });
upBtn.addEventListener('pointerup', (e) => { e.preventDefault(); touch.up = false; });
downBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); touch.down = true; downBtn.setPointerCapture(e.pointerId); });
downBtn.addEventListener('pointerup', (e) => { e.preventDefault(); touch.down = false; });

function processSteering(e) {
    const rect = padEl.getBoundingClientRect();
    let sInput = (e.clientX - (rect.left + rect.width / 2)) / (rect.width / 2);
    tractor.steerAngle = Math.max(-0.5, Math.min(0.5, sInput));
    ballEl.style.left = (50 + (sInput * 40)) + "%";
}

padEl.addEventListener('pointerdown', (e) => { e.preventDefault(); padEl.setPointerCapture(e.pointerId); processSteering(e); });
padEl.addEventListener('pointermove', (e) => { if (padEl.hasPointerCapture(e.pointerId)) processSteering(e); });
padEl.addEventListener('pointerup', (e) => { e.preventDefault(); tractor.steerAngle = 0; ballEl.style.left = "50%"; });
window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowUp' || e.key === 'w') touch.up = true;
    if (e.key === 'ArrowDown' || e.key === 's') touch.down = true;
    if (e.key === 'ArrowLeft' || e.key === 'a') { tractor.steerAngle = -0.5; ballEl.style.left = "10%"; }
    if (e.key === 'ArrowRight' || e.key === 'd') { tractor.steerAngle = 0.5; ballEl.style.left = "90%"; }
    if (e.key === ' ') handleHitch();
});
window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowUp' || e.key === 'w') touch.up = false;
    if (e.key === 'ArrowDown' || e.key === 's') touch.down = false;
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'ArrowRight' || e.key === 'd') { tractor.steerAngle = 0; ballEl.style.left = "50%"; }
});
draw();
</script>
</body>
</html>